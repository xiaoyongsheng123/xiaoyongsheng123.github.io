{"./":{"url":"./","title":"起始","keywords":"","body":"Document Library - 文档库 Here is the jsliang's learning and working experience document on programming. If you have doubts about this, please send an email to 1741020489@qq.com. 这里存放了 jsliang 的学习、工作中关于编程的经验文档。如果你对此有疑惑，请发邮件到 1741020489@qq.com。 新功能 GitHub 页面看得不舒服？ 试试 GitBook 的小册页面如何？ jsliang 制作了这个文档库的在线小册： LiangJunrong.github.io（每天更新） document.jsliang.top（每周更新） 欢迎评论吐槽！ 一 前言 本文档库始建于 2018-08-20。 如想知道 jsliang 最新学习进度，请前往 撰文思路 进行查看。 如想知道 jsliang 各种新奇玩意，请前往 网站清单 进行查看。 如想参与 jsliang 组织的小竞赛，请前往 个人竞赛 进行查看。 建文档库的初始目的：记录一下 jsliang 在折腾学习某个黑科技的时候的操作笔记。 因为，如果你学习而不写文章、不做笔记，某天你突发奇想，需要用到某个之前你用过的黑科技……那样的话，还需要 百度 / google 一遍，太累了！太浪费人生了！ 所以，集一生洪荒之力，写一个编程文档库，存放，我编程生涯的点点滴滴。 不折腾的前端，跟咸鱼有什么区别！ 二 文件目录 文件名 存放内容 CSS-library CSS 文档仓库 HTML-library HTML 文档仓库 JavaScript-library JavaScript 文档仓库 other-library 其他文档仓库(整站制作/微信小程序) public-repertory 文档仓库使用到的图片、CSS文件等…… 三 个人网站 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 四 反馈 QQ 群 如果对该文档库的某篇文章存有疑惑，如果有些问题想看下 jsliang 折腾过没有，请加 QQ 群：798961601。jsliang 在群里将第一时间根据小伙伴的疑问进行解答~ 五 推荐学习方法 建议小伙伴们有机会可以给自己配个显示器，也就 5/600 元，用起来也舒服。 jsliang 的开发配置为手提（16G / 6核 / 12线程 / 7200RMB） + 显示器 （21.5寸 / 1080P / 650RMB)。对前端开发的来说，这个价还是用得起的，而且自己的配置，自己用得会比较舒服。 最后，祝小伙伴们在编程生涯中找到自己的节奏，工资步步高升。 办公场景 学习场景 六 云服务器推广 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎加 QQ：1741020489 骚扰欢迎点击 云服务器推广 查看了解更多！ 七 打赏 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ 八 文档协议 document library of jsliang by 梁峻荣 is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Based on a work at https://github.com/LiangJunrong/document-library.Permissions beyond the scope of this license may be available at https://creativecommons.org/licenses/by-nc-sa/2.5/cn/. jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"文档库目录 起始 目录 更新记录 留言板 CSS 资料室 CSS 基础 CSS 重置 ✔ CSS 布局 Flex 布局 ✔ HTML 资料室 JavaScript 资料室 JavaScript Function 方法 - indexOf() ✔ 方法 - join() ✔ 方法 - map() ✔ 方法 - pop() ✔ 方法 - push() ✔ 方法 - reduce() ✔ 方法 - slice() ✔ 方法 - sort() ✔ 方法 - splice() ✔ 方法 - split() ✔ 方法 - substring() ✔ Object 对象 - Map ✔ 对象 - Math ✔ 对象 - Number ✔ 对象 - RegExp ✔ 对象 - Set ✔ 对象 - String ✔ 其他 删除数组项目的技巧 ✔ ES6学习 - 1 - Promise ✘ JavaScript 之 构造函数与原型对象 ✘ jQuery jQuery 基础 ✔ jQuery 工作常用解决方案 ✔ ECharts ECharts 打造在线个人简历 ✔ ECharts 打造在线个人简历 【升级版】 ✔ ECharts + Vue 折腾记 ✔ 设计模式 设计模式手册 - 1 - 部署开发环境 ✘ 设计模式手册 - 2 - 面向对象 ✘ 设计模式手册 - 3 - 工厂模式 ✘ 设计模式手册 - 4 - 单例模式 ✘ 设计模式手册 - 5 - 适配器模式 ✘ 设计模式手册 - 6 - 装饰器模式 ✘ 设计模式手册 - 7 - 代理模式 ✘ 设计模式手册 - 8 - 外观模式 ✘ 设计模式手册 - 9 - 观察者模式 ✘ 设计模式手册 - 10 - 迭代器模式 ✘ 设计模式手册 - 11 - 状态模式 ✘ 设计模式手册 - 12 - 其他模式 ✘ 设计模式手册 - 13 - 综合应用 ✘ Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:36:40 "},"News.html":{"url":"News.html","title":"更新记录","keywords":"","body":"文档库更新记录 Create by jsliang on 2019-5-24 08:25:32Recently revised in 2019-06-06 17:16:44 不折腾的前端，和咸鱼有什么区别 一 目前 更新时间：2019-06-06 [x] 链接：LeetCode - 027 - 移除元素 二 历史 [x] LeetCode - 026 - 删除排序数组中的重复项 [x] LeetCode - 20 - 有效的括号 [x] LeetCode - 14 - 最长公共前缀 [x] Markdown 打造静态网站 [x] LeetCode - 13 - 罗马数字转整数 [x] LeetCode - 9 - 回文数 [x] LeetCode - 7 - 整数反转 [x] LeetCode - 1 - 两数之和 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"MessageBoard.html":{"url":"MessageBoard.html","title":"留言板","keywords":"","body":"留言板 Create by jsliang on 2019-05-21 10:54:20Recently revised in 2019-05-22 17:36:30 不折腾的前端，和咸鱼有什么区别 欢迎小伙伴们加 jsliang 聊天吹水： 加 jsliang 的 QQ 资料群：798961601。 加 jsliang 的个人 QQ：1741020489 加 jsliang 的个人微信： jsliang 每周会抽取一些精辟留言或者交流内容在下方列出（后期可能给予红包奖励喔~），欢迎小伙伴们的吐槽。 精辟留言 2019/05 jsliang：“不折腾的前端，和咸鱼有什么区别” Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"CSS-library/":{"url":"CSS-library/","title":"CSS 资料室","keywords":"","body":"CSS 资料室 Create by jsliang on 2018-10-28 10:49:09Recently revised in 2019-05-30 21:33:24 Here is an article about CSS. 这里存放了关于 CSS 的文章。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"CSS-library/CSS-base/":{"url":"CSS-library/CSS-base/","title":"CSS 基础","keywords":"","body":"CSS 基础 Create by jsliang on 2019-5-20 08:34:15Recently revised in 2019-05-30 21:24:23 记录 CSS 基础相关的资料 目录 CSS Reset jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"CSS-library/CSS-base/CSS-reset.html":{"url":"CSS-library/CSS-base/CSS-reset.html","title":"CSS 重置 ✔","keywords":"","body":"CSS Reset Create by jsliang on 2018-12-23 20:12:08Recently revised in 2019-05-30 21:23:30 各式各样浏览器总有一些让人感觉难以接受的样式， 不管是 jQuery 还是 Vue 亦或者 React，使用前最好重置一下样式： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"CSS-library/layout/":{"url":"CSS-library/layout/","title":"CSS 布局","keywords":"","body":"CSS 布局 Create by jsliang on 2019-5-20 08:35:56Recently revised in 2019-05-30 21:28:06 记录 CSS 布局相关的资料 目录 Flex 布局 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"CSS-library/layout/Flex.html":{"url":"CSS-library/layout/Flex.html","title":"Flex 布局 ✔","keywords":"","body":"Flex 布局 create by jsliang on 2019-3-27 13:36:02Recently revised in 2019-05-30 21:25:35 万丈高楼平地起，熟悉 Flex 需要先了解 Flex 的下面这 6 个 CSS 属性： /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between; 下面我们详细分析这些元素的情况： 知识点 1. flex-direction：决定主轴的方向 row - （默认）水平方向，起点在左端 row-reverse - 水平方向，起点在右端 column - 垂直方向，起点在上沿 column-reverse - 垂直方向，起点在下沿 display: flex; flex-direction: row | row-reverse | column | column-reverse; 知识点 2. flex-wrap：一条轴线（一行）排不下时如何解决 nowrap - （默认）不换行 wrap - 换行，第一行在上方 wrap-reverse - 换行，第一行在下方 display: flex; flex-wrap: nowrap | wrap | wrap-reverse; 知识点 3. flex-flow：flex-flow = flex-direction + flex-wrap。即 flex-flow 是这两个属性的合集 row nowrap - （默认）水平方向，起点在左端，不换行 display: flex; flex-flow: || ; 详解参考 1 和 2 知识点 4. justify-content：定义项目在主轴上的对齐方式 flex-start - 左边对齐 flex-end - 右边对齐 center - 居中对齐 space-between - 两端对齐，空格在中间 space-around - 空格环绕 display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; 知识点 5. align-items：定义项目在交叉轴上如何对齐 flex-start - 顶部对齐，即文字图片等顶部同一条线上 flex-end - 底部对其，即文字图片等底部在同一条线上 center - 中间对其，即文字图片不管多高，都拿它们的中间放在同一条线上 stretch - 将文字图片充满整个容器的高度，强制统一 baseline - 将每项的第一行文字做统一在一条线上对齐 display: flex; align-items: flex-start | flex-end | center | stretch | baseline; 知识点 6. align-content：定义多根轴线的对齐方式。如果只有一根轴线（只有一行），该属性不起作用 flex-start - 这几行顶部对齐 flex-end - 这几行底部对齐 center - 这几行居中对齐 stretch - 这几行进行扩展或者缩放，从而填满容器高 space-between - 这几行中间使用空格进行填充 space-around - 这几行两边及中间进行填充 display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"HTML-library/":{"url":"HTML-library/","title":"HTML 资料室","keywords":"","body":"HTML 资料室 Create by jsliang on 2018-10-28 10:50:22Recently revised in 2019-5-20 08:24:19 Here is an article about HTMl 这里存放了关于HTML的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/":{"url":"JavaScript-library/","title":"JavaScript 资料室","keywords":"","body":"JavaScript 资料室 Create by jsliang on 2018-10-28 10:51:18Recently revised in 2019-5-20 08:24:52 Here is an article about JavaScript 这里存放了关于 JavaScript 的文章 目录 Angular ES6 ECharts JavaScript React Vue 设计模式 jQuery jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/":{"url":"JavaScript-library/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript 知识点 Create by jsliang on 2018-12-11 09:21:24Recently revised in 2019-05-30 21:50:15 一 序 万丈高楼平地起 地基还得自己起 记录 JavaScript 各个知识点 MDN 是个非常实用的网站，有不懂的知识点可尽管搜索： MDN 搜索页 下面知识点不分先后，如果有目的查找，请使用 Ctrl/Command + F： 二 Function 类型 名称 简介 地址 方法 indexOf() 判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 indexOf() 详细介绍 方法 map() 遍历数组，item 返回遍历项，index 返回当前索引。 map() 详细介绍 方法 pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 pop() 详细介绍 方法 sort() 排序，数字 1-9，字母 a-z。 sort() 详细介绍 三 Object 类型 名称 简介 地址 对象 Map 保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 Map 详细介绍 对象 Math 内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 Math 详细介绍 对象 Number 可以将其他类型的值转为数字。 Number 详细介绍 对象 String 将其他格式转成字符串。 String 详细介绍 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/":{"url":"JavaScript-library/JavaScript/Function/","title":"Function","keywords":"","body":"JavaScript - Function Create by jsliang on 2019-05-30 21:46:39Recently revised in 2019-06-06 13:41:11 记录一些 JavaScript 的关于 Function 的知识点。 目录 方法 - indexOf() 方法 - join() 方法 - map() 方法 - pop() 方法 - push() 方法 - reduce() 方法 - slice() 方法 - sort() 方法 - splice() 方法 - split() 方法 - substring() jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/indexOf.html":{"url":"JavaScript-library/JavaScript/Function/indexOf.html","title":"方法 - indexOf() ✔","keywords":"","body":"方法 - indexOf() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:37:49 原文：MDN - indexOf() 功能：indexOf() 方法返回调用 String 对象中第一次出现的指定值的索引。 语法：indexOf(searchValue, fromIndex) searchValue：查找的值 formIndex：开始查找的位置 返回值：如果找到了，则返回第一次出现的索引；如果没找到，则返回 -1。 代码： 'I am jsliang'.indexOf('a', 4); // 9 [1, 3, 1, 4].indexOf(1, 1); // 2 '怪盗 jsliang'.indexOf('我'); // -1 扩展：如果需要查找到最后一次出现指定值的索引，可以使用 lastIndexOf()。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/join.html":{"url":"JavaScript-library/JavaScript/Function/join.html","title":"方法 - join() ✔","keywords":"","body":"方法 - join() Create by jsliang on 2019-06-03 13:27:36Recently revised in 2019-06-03 13:32:51 原文：MDN - map() 功能：join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串 语法：arr.join(separator) separator 是合并的形式。例如 '' 就是不以任何形式拼接成字符串：['hello', 'hi'].join('') -> 'hellohi'；例如 '-' 就是以 - 形式拼接成字符串：['hello', 'hi'].join('') -> 'hello-hi' 返回值：一个所有数组元素连接的字符串。 代码： var a = ['Wind', 'Rain', 'Fire']; var myVar1 = a.join(); // myVar1 的值变为 \"Wind,Rain,Fire\" var myVar2 = a.join(', '); // myVar2的值变为\"Wind, Rain, Fire\" var myVar3 = a.join(' + '); // myVar3的值变为\"Wind + Rain + Fire\" var myVar4 = a.join(''); // myVar4的值变为\"WindRainFire\" jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/map.html":{"url":"JavaScript-library/JavaScript/Function/map.html","title":"方法 - map() ✔","keywords":"","body":"方法 - map() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:50:46 原文：MDN - map() 功能：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：map((item, index) => {}) item：遍历的项 index：该次遍历项的索引 返回值：一个新数组，每个元素都是回调函数的结果。 代码： [1, 2, 3, 4].map(item => item * 2) // [2, 4, 6, 8] [{ name: 'jsliang', age: 24, }, { name: '梁峻荣', age: 124 }].map((item, index) => { return `${index} - ${item.name}`; }) // ['0 - jsliang', '1 - 梁峻荣'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/pop.html":{"url":"JavaScript-library/JavaScript/Function/pop.html","title":"方法 - pop() ✔","keywords":"","body":"方法 - pop() Create by jsliang on 2019-05-19 11:40:27Recently revised in 2019-05-19 11:40:30 原文：MDN - pop() 功能：pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 语法： arr.pop()：返回从数组中删除的元素 返回值：一个新数组，每个元素都是回调函数的结果。 代码： let arr = [1, 2, 3, 4]; for(let i = 0, time = 1; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/push.html":{"url":"JavaScript-library/JavaScript/Function/push.html","title":"方法 - push() ✔","keywords":"","body":"方法 - push() Create by jsliang on 2019-06-04 14:35:40Recently revised in 2019-06-04 14:39:37 原文：MDN - push() 功能：push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 语法：arr.push(element) element：需要传入到数组的元素 返回值：当调用该方法时，新的 length 属性值将被返回。 代码： let arr = []; arr.push(1); arr.push('2'); arr.push([3, 4, 5]); arr.push([...6, 7, 8]); console.log(arr); /* [1, \"2\", Array(3), 6, 7, 8] 0: 1 1: \"2\" 2: (3) [3, 4, 5] 3: 6 4: 7 5: 8 length: 6 */ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/reduce.html":{"url":"JavaScript-library/JavaScript/Function/reduce.html","title":"方法 - reduce() ✔","keywords":"","body":"方法 - reduce() Create by jsliang on 2019-06-03 16:53:03Recently revised in 2019-06-03 17:06:15 原文：MDN - reduce() 功能：reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 语法：arr.reduce((prev, next) => { return prev + next } prev：数组前一项的值 next：数组后一项的值 return：return 出来的值，会被当成下一次的 prev 返回值：函数累计处理的结果 代码： [1, 2, 3, 4].reduce((prev, next) => { return prev + next; }); // 10 ['前端', 'pang', 'liang'].reduce((prev, next, index) => { return (index = 0 ? '-js' : '') + prev + 'js' + next; }); // 前端-jspang-jsliang jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/slice.html":{"url":"JavaScript-library/JavaScript/Function/slice.html","title":"方法 - slice() ✔","keywords":"","body":"方法 - slice() Create by jsliang on 2019-06-03 16:55:09Recently revised in 2019-06-03 17:04:11 原文：MDN - slice() 功能：slice() 方法提取一个字符串的一部分，并返回一新的字符串。 语法：str.slice(beginSlice, endSlice) beginSlice：从该索引（以 0 为基数）处开始提取原字符串中的字符。 endSlice：结束位置（以 0 为基数）。 返回值：返回一个从原字符串中提取出来的新字符串。 代码： const str = 'jsliang'; str.slice(0, 2); // 'js' str.slice(2); // 'liang' jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/sort.html":{"url":"JavaScript-library/JavaScript/Function/sort.html","title":"方法 - sort() ✔","keywords":"","body":"方法 - sort() Create by jsliang on 2019-05-17 11:31:56Recently revised in 2019-05-17 14:57:45 原文：MDN - sort() 功能：sort() 对数组的元素进行排序，并返回数组。 语法：sort(function) function：按某种顺序进行排列的函数。 返回值：排序后的数组。 代码： [4, 2, 5, 1, 3].sort(), // [1, 2, 3, 4, 5] [4, 2, 5, 1, 3].sort((a, b) => a jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/splice.html":{"url":"JavaScript-library/JavaScript/Function/splice.html","title":"方法 - splice() ✔","keywords":"","body":"方法 - splice() Create by jsliang on 2019-06-06 13:31:28Recently revised in 2019-06-06 13:31:32 原文：MDN - splice() 功能：splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 语法：array.splice(start, deleteCount, item1, item2, ...) start：指定修改的开始位置（从0计数）。 deleteCount：整数，表示要移除的数组元素的个数。 item1, item2, ...：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 返回值：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 代码： var months = ['Jan', 'March', 'April', 'June']; months.splice(1, 0, 'Feb'); console.log(months); // ['Jan', 'Feb', 'March', 'April', 'June'] months.splice(4, 1, 'May'); console.log(months); // ['Jan', 'Feb', 'March', 'April', 'May'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/split.html":{"url":"JavaScript-library/JavaScript/Function/split.html","title":"方法 - split() ✔","keywords":"","body":"方法 - split() Create by jsliang on 2019-05-23 11:09:56Recently revised in 2019-05-23 11:14:11 原文：MDN - split() 功能：split() 方法使用指定的分隔符字符串将一个 String 对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 语法：str.split('.') '.'：即分割的形式，这里通过 . 来划分，如果是 '' 空，那么就单个字符拆分，如果是 '|'，那么通过 | 来划分。 返回值：一个新数组。返回源字符串以分隔符出现位置分隔而成的一个数组。 代码： String(12321).split(''); // ['1', '2', '3', '2', '1'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Function/substring.html":{"url":"JavaScript-library/JavaScript/Function/substring.html","title":"方法 - substring() ✔","keywords":"","body":"方法 - substring() Create by jsliang on 2019-06-03 15:19:08Recently revised in 2019-06-03 16:19:51 原文：MDN - substring() 功能：substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 语法：str.substring(start, end) start：需要截取的第一个字符的索引，该字符作为返回的字符串的首字母。 end：可选。0 - n，即从 start 开始，截取 end 位长度的字符串。 返回值：包含给定字符串的指定部分的新字符串。 代码： var str = 'jsliang'; str.substring(0, 2); // js str.substring(2); // liang jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/":{"url":"JavaScript-library/JavaScript/Object/","title":"Object","keywords":"","body":"JavaScript - Object Create by jsliang on 2019-05-30 21:46:21Recently revised in 2019-06-06 13:53:33 记录一些 JavaScript 的关于 Function 的知识点。 目录 对象 - Map 对象 - Math 对象 - Number 对象 - RegExp 对象 - Set 对象 - String jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/Map.html":{"url":"JavaScript-library/JavaScript/Object/Map.html","title":"对象 - Map ✔","keywords":"","body":"对象 - Map Create by jsliang on 2019-05-17 11:45:35Recently revised in 2019-06-06 13:51:17 原文：MDN - Map 功能：Map 对象保存键值对。 方法： new Map()：新建一个 Map 对象 Map.prototype.has(key)：返回布尔值。表示 Map 实例是否包含键对应的值。 Map.prototype.set(key, value)：返回该 Map 对象。设置 Map 对象中键的值。 Map.prototype.get(key)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.delete(key)：如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。 代码： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/Math.html":{"url":"JavaScript-library/JavaScript/Object/Math.html","title":"对象 - Math ✔","keywords":"","body":"对象 - Math Create by jsliang on 2019-05-19 11:32:44Recently revised in 2019-06-06 13:51:34 原文：MDN - Math 功能：Math 是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 方法： Math.abs(x)：返回 x 的绝对值。 Math.ceil(x)：返回 x 向上取整后的值。x = 99.1; result = 100 Math.floor(x)：返回小于 x 的最大整数。x = 99.1; result = 99 Math.pow(x,y)：返回 x 的 y 次幂。 Math.round(x)：返回四舍五入后的整数。 代码： Math.abs(-999); // 999 Math.ceil(99.1); // 100 Math.floor(99.1); // 99 Math.pow(2, 3); // 8 Math.round(99.5); // 100 Math.round(99.4); // 99 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/Number.html":{"url":"JavaScript-library/JavaScript/Object/Number.html","title":"对象 - Number ✔","keywords":"","body":"对象 - Number Create by jsliang on 2019-05-19 11:17:28Recently revised in 2019-06-06 13:51:59 原文：MDN - Number 功能：Number 可以将其他类型的值转为数字。 方法： new Map()：新建一个 Map 对象 Number(x)：将其他类型的值转为数字 Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2 的 53 次方 - 1)。 Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 (-(2 的 53 次方 - 1)). 代码： Number(\"123\") // 123 Number(\"\") // 0 Number(\"0x11\") // 17 Number(\"0b11\") // 3 Number(\"0o11\") // 9 Number(\"foo\") // NaN Number(\"100a\") // NaN jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/RegExp.html":{"url":"JavaScript-library/JavaScript/Object/RegExp.html","title":"对象 - RegExp ✔","keywords":"","body":"对象 - RegExp Create by jsliang on 2019-06-03 16:13:48Recently revised in 2019-06-03 16:19:04 原文：MDN - String 功能：通过正则表达式，进行一些便捷操作。 推荐：小伙伴可以查看 jsliang 写的文章：正则表达式学习 来快速入门正则表达式。 代码： '@flow@flight'.match(new RegExp(`${'@fl'}`,\"g\")); // ['@fl', '@fl'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/Set.html":{"url":"JavaScript-library/JavaScript/Object/Set.html","title":"对象 - Set ✔","keywords":"","body":"对象 - Set Create by jsliang on 2019-06-06 13:47:16Recently revised in 2019-06-06 13:47:20 原文：MDN - Set 功能：Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 方法： new Set([iterable]);：如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。 代码： let a = [...new Set([1, 1, 2, 3])]; console.log(a); // [1, 2, 3] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Object/String.html":{"url":"JavaScript-library/JavaScript/Object/String.html","title":"对象 - String ✔","keywords":"","body":"对象 - String Create by jsliang on 2019-05-19 11:17:49Recently revised in 2019-06-06 13:52:16 原文：MDN - String 功能：String 将其他值生成或转换成字符串。 方法： String(thing)：将 thing 转成字符串。 代码： String(123); // '123' String(true); // 'true' jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Other/":{"url":"JavaScript-library/JavaScript/Other/","title":"其他","keywords":"","body":"JavaScript - 其他 Create by jsliang on 2019-05-30 21:44:49Recently revised in 2019-05-30 21:44:46 记录一些 JavaScript 的关于 Function 的知识点。 目录 删除数组项目的技巧 ES6学习 - 1 - Promise JavaScript 之 构造函数与原型对象 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html":{"url":"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html","title":"删除数组项目的技巧 ✔","keywords":"","body":"删除数组项目的技巧 Create by jsliang on 2019-4-5 09:56:19Recently revised in 2019-4-6 10:34:11 /** * 这里使用了三种写法 * 1. map + splice * 2. splice + findIndex * 3. filter */ // 1. map + splice 写法 deleteInfo(recycleItem) { this.todoInfos.map((item, index) => { if(item.id == recycleItem.id) { this.todoInfos.splice(index, 1); } }) }, // 2. splice + findIndex 写法 deleteInfo(recycleItem) { this.todoInfos.splice( this.todoInfos.findIndex( v => v.id === recycleItem.id), 1); }, // 3. filter 写法 deleteInfo(recycleItem) { this.todoInfos = this.todoInfos.filter( (x) => { return x.id != recycleItem.id; }) } Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Other/Promise.html":{"url":"JavaScript-library/JavaScript/Other/Promise.html","title":"ES6学习 - 1 - Promise ✘","keywords":"","body":"ES6学习 - 1 - Promise create by jsliang on 2018-8-23 14:26:38Recently revised in 2018-12-23 20:35:05 PS：由于工作突然来活，Promise学习暂且放下，jsliang会利用下班时间慢慢补充。 学习导言  在学习Promise前，我们先理解两组词：单线程和多线程、同步和异步。 单线程和多线程：在你选购电脑的时候，也许会时不时听导购员跟你推荐：“这台机子是6核12线程的” “这台机子是4核8线程的”……啪啦啪啦介绍一番，然后你就纳闷了，什么是线程？线程是干什么的？……哎~停！专业的解释小伙伴们可以去看专业的回答：线程、单线程和多线程、单线程和多线程的区别。在这里，我们通过一个通俗易懂的小场景，带大家去理解单线程和多线程： 图（一堆钱） 图（单线程抢钱） 图（多线程抢钱） 解释：通过这个小场景，我们明白了单线程和多线程是什么样子的。下面我们继续了解同步和异步。 同步和异步：文章1、文章2、文章3 在理解了 单线程和多线程、同步和异步的基础上，我们来看看单线程的JavaScript是如何通过Promise来实现异步操作的。 借鉴与领悟  今天我们看看邵哥关于Promise的文章，理解下Promise的世界。先行观赏 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/JavaScript/Other/prototype&constructor.html":{"url":"JavaScript-library/JavaScript/Other/prototype&constructor.html","title":"JavaScript 之 构造函数与原型对象 ✘","keywords":"","body":"JavaScript 之 构造函数与原型对象 Create by jsliang on 2018-12-11 09:27:44Recently revised in 2018-12-25 20:43:57 “每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。”—— 《JavaScript 高级程序设计》 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 箭头函数  3.2 不能使用箭头函数的场景  3.3 构造函数和原型对象 四 总结 二 前言 返回目录  在编写学习 Node 基础 中，写到 Node 仿 Express 的时候，我写了这么一段代码： let Application = () => { // ... } Application.prototype.get = (path, handle) => { // ... }  然后代码死活跑不起来，于是我就去问大佬，大佬默默回了句： “构造函数不能用箭头函数呀”  我一愣： 为什么不能用构造函数？ 什么时候我不能使用构造函数？ 箭头函数的解释是什么咯？ 什么是构造函数？ ……  所以，在下面，咱一一分析这些问题。 三 正文 返回目录  参考文献： 箭头函数 | 廖雪峰的官网 什么时候你不能使用箭头函数？ | 简书 - 王仕军 js深入理解构造函数和原型对象 | 博客园 - 快饿死的鱼 一句话总结JS构造函数、原型和实例的关系 | CSDN - 夜色芜染 箭头函数 | MDN 3.1 箭头函数 返回目录  ES6 标准新增了一种新的函数：Arrow Function(箭头函数)。 为什么叫箭头函数？ x => x * x;  因为它的定义用的就是一个箭头。上面代码相当于： function(x) { return x * x; }  那么，它的作用是什么呢：箭头函数相当于匿名函数，并且简化了函数定义。而箭头函数内部的 this 是词法作用域，由上下文确定： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this 指向 window 或 undefined }; return fn(); } };  在上文的代码中： return new Date().getFullYear() - this.birth;  这里的 this 指向 window 或 undefined，从而使 JavaScript 函数对 this 的绑定没有得到预期的结果。 那么，我们可以尝试使用箭头函数： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () => new Date().getFullYear() - this.birth; // this 指向 obj 对象 return fn(); } }; obj.getAge(); // 25  这就是箭头函数及其大致作用。 3.2 不能使用箭头函数的场景 返回目录  什么时候不能使用箭头函数呢？ 定义对象方法 定义原型方法 定义构造函数 定义事件回调函数  首先，在定义对象方法中，举例： const calculator = { array: [1, 2, 3], sum: () => { console.log(this === window); // => true return this.array.reduce((result, item) => result + item); } }; console.log(this === window); // => true // Throws \"TypeError: Cannot read property 'reduce' of undefined\" calculator.sum();  如上，它会报错，因为 this 的指向不对，需要修改为： const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // => true return this.array.reduce((result, item) => result + item); } }; calculator.sum(); // => 6  然后，在定义原型方法上，也需要注意不能滥用箭头函数： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () => { console.log(this === window); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => undefined  这里需要修改为： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = function () { console.log(this === cat); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => 'Mew'  接着，在定义事件回调函数时，也需要注意 this 的指向： const button = document.getElementById('myButton'); button.addEventListener('click', () => { console.log(this === window); // => true this.innerHTML = 'Clicked button'; });  修正为： const button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log(this === button); // => true this.innerHTML = 'Clicked button'; });  最后，在定义构造函数上： const Message = (text) => { this.text = text; }; // Throws \"TypeError: Message is not a constructor\" const helloMessage = new Message('Hello World!');  修正为： const Message = function(text) { this.text = text; }; const helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // => 'Hello World!'  综合 3.1 与 3.2 的内容，我们可以清晰明白，虽然使用箭头函数，能够精简代码，并在一定程度上有所帮助。 但是，我们不能因为追求简洁的代码，而提升我们的代码维护难度和造成多种 bug。 量力而行才是最好的。 3.3 构造函数和原型对象 返回目录   四 总结 返回目录   jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/jQuery/":{"url":"JavaScript-library/jQuery/","title":"jQuery","keywords":"","body":"jQuery Create by jsliang on 2018-11-4 10:38:08Recently revised in 2019-05-31 13:10:32 记录 jQuery 学习及 jQuery 工作日常 目录 jQuery 基础 jQuery 工作常用解决方案 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/jQuery/jQuery-base.html":{"url":"JavaScript-library/jQuery/jQuery-base.html","title":"jQuery 基础 ✔","keywords":"","body":"jQuery 基础 Create by jsliang on 2018-05-07 15:56:17Recently revised in 2019-05-30 23:45:51 jQuery 操作 DOM 的那一套，还是非常值得关注的。我那时候一直想看 妙味 的 jQuery 剖析，我会员都买了，但是那会又去折腾小程序了，所以就没空了。 其实我觉得，jQuery 不是说丢就能丢的，只是前端新人，都觉得 Vue、React 工作好找，就学点 JavaScript 皮毛，去折腾那个去了。但是，讲真原生 JavaScript 还是要操作 DOM 的，DOM 操作哪家强，前端技术找 jQuery。 而且，一些开发中，直接用 jQuery 暴力拆迁，还是挺快的。我觉得我以后不用 jQuery 的原因，可能是项目涉及的数据量太大，操作 DOM 太多的时候，我才会更换成 Vue 这些。 最后的最后，一句话吧：没有最屌的技术，只有最适合项目的技术。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 尝试 四 兼容 五 jQuery 语法 六 jQuery 选择器  6.1 元素选择器  6.2 #ID 选择器  6.3 .class 选择器  6.4 其他用法 七 DOM 事件  7.1 mouseover 与 mouseenter  7.2 键盘事件顺序 八 jQuery 效果  8.1 显示/隐藏  8.2 淡入/淡出  8.3 滑动  8.4 动画  8.5 停止动画  8.6 链 九 捕获 十 设置 十一 添加元素 十二 删除元素 十三 CSS 类 十四 CSS() 方法 十五 尺寸 十六 祖先选择器 十七 后代选择器 十八 同胞选择器 十九 过滤选择器 二十 load 二十一 get() 和 post() 二十二 Ajax 二十三 JSONP 二十四 无冲突 - noConflict 二十五 jQuery 实例 二十六 选择器扩展  26.1 基本选择器  26.2 层次选择器  26.3 过滤选择器（重点）   26.3.1 内容过滤选择器   26.3.2 可见性过滤选择器  26.4 属性过滤选择器  26.5 状态过滤选择器  26.6 表单选择器 二十七 插件扩展  27.1 jQuery Validate  27.2 jQuery Accordion  27.3 jQuery Autocomplete  27.4 jQuery Growl  27.5 jQuery Password Validation  27.6 jQuery Prettydate  27.7 jQuery Treeview 二 前言 返回目录 本文最初用 Word 记录于 2018-05-07。 那时候还是前端职场新人，想在想起还是非常感谢带我的前端小姐姐的指导。 这篇文章是在 jQuery 教程 | 菜鸟教程 学习的过程中的记录笔记。 如需系统学习 jQuery，建议参考网上现成的系统的 jQuery 网站教程/视频教程。 本文仅供 jQueryer 复习自己所学知识。 三 尝试 返回目录 jQuery是一个轻量级的 \"写的少，做的多\" 的 JavaScript 库。 jQuery 的引用： 百度 CDN： jQuery 官网 CDN： BootCDN： 尝试： index.html 尝试引用jQuery - 2018年5月7日16:20:50 点我？消失给你看哦~ 继续点试试？ 再点试试？ $(document).ready(function(){ $(\"p\").click(function(){ $(this).hide(); }); }); 四 兼容 返回目录 jQuery 版本 2 以上不支持 IE6，7，8 浏览器。 如果需要支持 IE6/7/8，那么请选择 1.9。 你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 五 jQuery 语法 返回目录  基础语法： $(selector).action()。在jQuery中，$=jQuery  ready： 写法1：$(document).ready(function(){ // 开始写 jQuery 代码... }); 写法2：$(function(){ // 开始写 jQuery 代码... }); 六 jQuery 选择器 返回目录 jQuery 选择器可以帮助我们更好地选择 DOM 元素。 6.1 元素选择器 返回目录 在页面中选取所有 元素: js 代码片段 // $(\"p\"); // 实例： $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(); }); }); 6.2 #ID 选择器 返回目录 通过 id 选取元素语法如下：$(\"#test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); 6.3 .class 选择器 返回目录 jQuery 类选择器可以通过指定的 class 查找元素：$(\".test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 6.4 其他用法 返回目录 语法 描述 $(\"*\") 选取所有元素 $(this) 选取当前 HTML 元素 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"[href]\") 选取带有 href 属性的元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 七 DOM 事件 返回目录 鼠标事件 键盘事件 表单事件 文档/窗口事件 click - 点击 keypress - 键被按下 submit - 表单提交 load - 全部加载（1.8已废弃） dbclick - 双击 keydown - 键按下的过程 change - 文本改变 resize - 浏览器窗口大小调试 mouseenter - 鼠标进入 keyup - 键被松开 focus - 获得焦点 scroll - 滚动 mouseleave - 鼠标离开   blur - 失去焦点 unload - 离开页面（1.8已废弃） 7.1 mouseover 与 mouseenter 返回目录 mouseover 事件在鼠标移动到选取的元素及其子元素上时触发。 mouseenter 事件只在鼠标移动到选取的元素上时触发。 mouseleave 与 mouseout同样。 7.2 键盘事件顺序 返回目录 keydown - 键按下的过程 keypress - 键被按下 keyup - 键被松开 八 jQuery 效果 返回目录 jQuery 可以使用其事件，做一些好玩的事情 8.1 显示/隐藏 返回目录 语法： 隐藏：$(selector).hide(speed,callback); 显示：$(selector).show(speed,callback); 切换：$(selector).toggle(speed,callback); speed：速度（毫秒） callback：完成后显示的函数 index.html 显示与隐藏 如果你点击“隐藏” 按钮，我将会消失。 隐藏 显示 $(function () { $(\"#hide\").click(function () { $(\"p\").hide(5000); }); $(\"#show\").click(function () { $(\"p\").show(1000); }); }); 8.2 淡入/淡出 返回目录 语法： 淡入：$(selector).fadeIn(speed,callback); 淡出：$(selector).fadeOut(speed,callback); 切换：$(selector).fadeToggle(speed,callback); 渐变：$(selector).fadeTo(speed,opacity,callback); speed：速度 opacity：透明度 callback：回调函数 index.html 淡入与淡出 .container { width: 320px; margin: 0 auto; } #red { width: 100px; height: 100px; background: red; } #green { width: 100px; height: 100px; background: green; } #blue { width: 100px; height: 100px; background: blue; } #fadeIn { display: none; } 淡入 淡出 渐变 $(function(){ $(\"#fadeToggle\").click(function(){ $(\"#blue\").fadeToggle(1000,function(){ $(\"#green\").fadeToggle(500,function(){ $(\"#red\").fadeToggle(200) }); }); $(\"#fadeIn\").toggle(); $(\"#fadeOut\").toggle(); }); $(\"#fadeTo\").click(function(){ $(\"#red\").fadeTo(500,0.3); $(\"#green\").fadeTo(1000,0.5); $(\"#blue\").fadeTo(\"slow\",0.1); }) }); 8.3 滑动 返回目录 语法： $(selector).slideDown(speed,callback); $(selector).slideUp(speed,callback); $(selector).slideToggle(speed,callback); speed：时间 callback：回调函数 index.html 显示与隐藏 #toggleHide { display: none; } 显示 隐藏 如果你点击“隐藏” 按钮，我将会消失。 $(function () { $(\"#toggle\").click(function () { $(\"#toggleHide\").toggle() $(\"#toggleShow\").toggle(); $(\"p\").toggle(1000); }); }); 8.4 动画 返回目录 语法： $(selector).animate({params},speed,callback); params：css 属性（键值对形式，-号替换为驼峰 → border-radius=borderRadius:'15px'） speed：时间 callback：回调函数 操作： 能操作单个属性 能操作多个属性 值能使用相对值（+=、-=） 属性值能为\"show\"、\"hide\" 或 \"toggle\"等 编写多个animate能使用队列功能 index.html 动画 .container { width: 320px; margin: 0 auto; text-align: center; } #circle { width: 100px; height: 100px; border-radius: 50px; background: rgb(243, 207, 5); display: inline-block; position: relative; } #stop { display: none; } start! stop! $(function () { var start; $(\"#stop\").click(function(){ clearInterval(start); $(\"#start\").show(); $(\"#stop\").hide(); }); $(\"#start\").click(function(){ start = setInterval(\"runBall()\", 1000); $(\"#start\").hide(); $(\"#stop\").show(); }); }); function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }); $(\"#circle\").animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }); $(\"#circle\").animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 8.5 停止动画 返回目录 语法： $(selector).stop(stopAll,goToEnd); stopAll：默认 false。true：停止包括后续 animate 的所有动作 goToEnd：默认 false。true：直接跳到该动作末尾，同时停止后面动作 index.html 停止动画 .container { width: 320px; margin: 0 auto; } #text { background: #b9f309; position: relative; } #text p { text-indent: 2em; } 开始 停止 停止所有 停止动画，但完成动作 点击 \"开始\" 按钮开始动画。 点击 \"停止\" 按钮停止当前激活的动画，但之后我们能再动画队列中再次激活。 点击 \"停止所有\" 按钮停止当前动画，并清除动画队列，所以元素的所有动画都会停止。 点击 \"停止动画，但完成动作\" 快速完成动作，并停止它。 $(function () { $(\"#start\").click(function () { $(\"#text\").animate({ top: '200px' }, 1000); $(\"#text\").animate({ top: '0' }, 1000); }); $(\"#stopDefault\").click(function(){ $(\"#text\").stop(); }) $(\"#stopAll\").click(function(){ $(\"#text\").stop(true); }) $(\"#stopToEnd\").click(function(){ $(\"#text\").stop(true,true); }) }); 8.6 链 返回目录 jQuery可以通过链的形式，链接多个动作。 修改 8.4 动画的代码： js 代码片段 function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }).animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }).animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 九 捕获 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值 index.html 捕获 .container { width: 320px; margin: 0 auto; } 显示文本 显示HTML 显示表单值 显示属性 这是段落中的粗体 文本。 梁峻荣的网站 $(function(){ $(\"#showText\").click(function(){ alert(\"显示文本：\"+$(\"#text\").text()); }); $(\"#showHtml\").click(function(){ alert(\"显示HTML：\"+$(\"#text\").html()); }); $(\"#showVal\").click(function(){ alert(\"显示表单值：\"+$(\"#webSkill\").val()); }); $(\"#showAttr\").click(function(){ alert(\"显示属性：\"+$(\"#myBlog\").attr(\"target\")); }); }); 十 设置 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值 在设置方面，这4个方法还提供回调函数。 index.html 设置 .container { width: 320px; margin: 0 auto; } 修改文本 这是段落中的 粗体 文本。 修改HTML 这是段落中的 粗体 文本。 修改表单值 修改属性1 梁峻荣的网站 修改属性2 便捷校园 $(function(){ $(\"#changeText\").click(function(){ $(\"#text\").text(\"Hello World!\"); }); $(\"#changeHtml\").click(function(){ $(\"#htmlText\").html(\"Hello World！\"); }); $(\"#changeVal\").click(function(){ $(\"#webSkill\").val(\"Hello World!\"); }); $(\"#changeAttr1\").click(function(){ $(\"#myBlog1\").text(\"便捷校园\").attr(\"href\", \"http://www.liangjunrong.com:3000\"); }); $(\"#changeAttr2\").click(function(){ $(\"#myBlog2\").text(\"梁峻荣的网站\").attr({ \"href\":\"http://www.liangjunrong.com\", \"target\":\"\" }); }); }); 十一 添加元素 返回目录 append() - 在被选的元素的结尾插入内容 prepend() - 在被选的元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 index.html 添加元素 #container { background: red; } append追加文本 after追加文本 这是一个段落。 Hello World! function appendText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").append(txt1, txt2, txt3); // 追加新元素 } function afterText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").after(txt1, txt2, txt3); // 追加新元素 } 十二 删除元素 返回目录 remove() - 删除被选元素（及其子元素）（可附加参数） empty() - 从被选元素中删除子元素 index.html 删除元素 .container { width: 320px; margin: 0 auto; } #text { width: 200px; height: 200px; background: rgb(255, 217, 0); } remove元素 empty元素 remove部分元素 Hello World! Hello World! Liang~ Hello GuangZhou! $(function(){ $(\"#remove\").click(function(){ $(\"#text\").remove(); }); $(\"#empty\").click(function(){ $(\"#text\").empty(); }); $(\"#removeFew\").click(function(){ $(\"p\").remove(\".pText\"); }); }); 十三 CSS 类 返回目录 addClass() - 向被选元素添加一个类或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 index.html CSS类 .container { width: 320px; margin: 0 auto; } .changeClass { background: rgb(0, 255, 179); } 添加样式 Hello World! 我叫梁峻荣！ $(function () { $(\"#addClass\").click(function () { $(\"#changeClass\").toggleClass(\"changeClass\"); }); }); 十四 CSS() 方法 返回目录 语法： 返回CSS： css(\"propertyname\"); 修改CSS： css(\"propertyname\",\"value\"); index.html CSS类 .container { width: 320px; margin: 0 auto; } p { background: red; } 获取CSS 修改CSS 这是一个段落。 $(function () { $(\"#getCss\").click(function () { alert($(\"p\").css(\"background\")); }); $(\"#changeCss\").click(function () { $(\"p\").css({ \"background\": \"red\", \"fontSize\": \"30px\" }); }); }); 十五 尺寸 返回目录 width() - 元素宽度 height() - 元素高度 innerWidth() - padding+元素 宽度 innerHeight() - padding+元素 高度 outerWidth() - border+padding+元素 宽度 outerHeight() - border+padding+元素 高度 index.html 尺寸 .container { width: 320px; margin: 0 auto; text-align: center; } .box { width: 220px; height: 220px; padding: 10px; border: 5px solid #ccc; background: rgb(6, 193, 240); display: inline-block; } 显示width 显示height 显示innerWidth 显示innerHeight 显示outerWidth 显示outerHeight $(function(){ $(\"#showWidth\").click(function(){ var width = \"div的width是：\" + $(\".box\").width() + \"\"; $(\"#width\").html(width); }); $(\"#showHeight\").click(function(){ var height = \"div的height是：\" + $(\".box\").height() + \"\"; $(\"#height\").html(height); }); $(\"#showInnerWidth\").click(function(){ var innerWidth = \"div的innerWidth是：\" + $(\".box\").innerWidth() + \"\"; $(\"#innerWidth\").html(innerWidth); }); $(\"#showInnerHeight\").click(function(){ var innerHeight = \"div的innerHeight是：\" + $(\".box\").innerHeight() + \"\"; $(\"#innerHeight\").html(innerHeight); }); $(\"#showOuterWidth\").click(function(){ var outerWidth = \"div的outerWidth是：\" + $(\".box\").outerWidth() + \"\"; $(\"#outerWidth\").html(outerWidth); }); $(\"#showOuterHeight\").click(function(){ var outerHeight = \"div的outerHeight是：\" + $(\".box\").outerHeight() + \"\"; $(\"#outerHeight\").html(outerHeight); }); }); 十六 祖先选择器 返回目录 parent() - 上一级父元素 parents() - 上至html标签 parentsUntil() - 介于目前元素与选择元素之间的所有标签。 index.html 祖先 .container { width: 320px; margin: 0 auto; text-align: center; } .ancestorsClass { color: rgb(0, 0, 0); border: 2px solid rgb(0, 247, 255); } body （曾曾祖父元素） div （曾祖父元素） parent parents parents刷选 parentsUntil 清空 ul （祖父元素） li （父元素） span $(function(){ $(\"#parent\").click(function(){ $(\"span\").parent().addClass(\"ancestorsClass\"); }); $(\"#parents\").click(function(){ $(\"span\").parents().addClass(\"ancestorsClass\"); }); $(\"#parentsSelect\").click(function(){ $(\"span\").parents(\"ul\").addClass(\"ancestorsClass\"); }); $(\"#parentUntil\").click(function(){ $(\"span\").parentsUntil(\"div\").addClass(\"ancestorsClass\"); }); $(\"#clear\").click(function(){ $(\"span\").parents().removeClass(\"ancestorsClass\"); }); }); 十七 后代选择器 返回目录 children() - 所选元素的所有直接子元素 find() - 找到符合条件的子元素 index.html 后代 .container { width: 320px; margin: 0 auto; text-align: center; } .boxClass { font-size: 2em; color: rebeccapurple; } children find Hello World! !dlroW olleH $(function(){ $(\"#children\").click(function(){ $(\"#box\").children(\"p.p1\").addClass(\"boxClass\"); }); $(\"#find\").click(function(){ $(\"#box\").find(\"*\").addClass(\"boxClass\"); }); }); 十八 同胞选择器 返回目录 siblings() - 被选元素的所有同胞元素 next() - 被选元素的下一个元素 nextAll() - 被选元素的下面所有元素 nextUntil() - 被选元素到后面指定元素中间的所有元素 prev() - 被选元素的前一个元素 prevAll() - 被选元素的前面所有元素 prevUntil() - 被选元素到前面指定元素中间的所有元素 index.html 同胞 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } sibling next nextAll nextUntil prev prevAll prevUntil clear Hello! Hello! Hello! Hello! Hello! Hello! $(function () { $(\"#sibling\").click(function () { $(\"h3\").siblings(\"h4\").addClass(\"textClass\"); }); $(\"#next\").click(function () { $(\"h1\").next().addClass(\"textClass\"); }); $(\"#nextAll\").click(function () { $(\"h1\").nextAll().addClass(\"textClass\"); }); $(\"#nextUntil\").click(function () { $(\"h3\").nextUntil(\"h6\").addClass(\"textClass\"); }); $(\"#prev\").click(function () { $(\"h6\").prev().addClass(\"textClass\"); }); $(\"#prevAll\").click(function () { $(\"h6\").prevAll().addClass(\"textClass\"); }); $(\"#prevUntil\").click(function () { $(\"h6\").prevUntil(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function () { $(\"#box\").children().removeClass(\"textClass\"); }); }); 十九 过滤选择器 返回目录 first() - 第一个匹配条件的元素 last() - 最后一个匹配条件的元素 eq() - 符合索引号的元素 filter() - 匹配filter里条件的元素 not() - 去掉not里符合条件的元素后的其他元素 index.html 过滤 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } first last eq filter not clear Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! $(function(){ $(\"#first\").click(function(){ $(\"#box h3\").first().addClass(\"textClass\"); }); $(\"#last\").click(function(){ $(\"#box h3\").last().addClass(\"textClass\"); }); $(\"#eq\").click(function(){ $(\"#box\").children().eq(2).addClass(\"textClass\"); }); $(\"#filter\").click(function(){ $(\"#box\").children().filter(\"h3\").addClass(\"textClass\"); }); $(\"#not\").click(function(){ $(\"#box\").children().not(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function(){ $(\"#box\").children().removeClass(\"textClass\"); }) }); 二十 load 返回目录 语法：$(selector).load(URL,data,callback); URL：请求加载的URL data：查询字符串键值对集合 callback：load() 方法完成后所执行的函数名称 responseTxt - 包含调用成功时的结果内容 statusTxt - 包含调用的状态 xhr - 包含XMLHttpRequest对象 二十一 get() 和 post() 返回目录 get - 从指定的资源请求数据 post - 向指定的资源提交要处理的数据 语法： $.get(URL,callback); URL：请求的 URL callback：请求成功后所执行的函数名 二十二 Ajax 返回目录 语法：$.ajax({name:value, name:value, ... }) 方法 1： js 代码片段1 $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); }); 方法 2： js 代码片段2 $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { \"#search-name\").val()) + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 二十三 JSONP 返回目录 跨域读取数据，请用 JSONP。 注意：JSONP 与 Ajax 没任何关系！JSONP 是利用 script 标签来 get 到被包裹的 json 数据。 index.html JSONP $.getJSON(\"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function (data) { var html = ''; for (var i = 0; i ' + data[i] + ''; } html += ''; $('#divCustomers').html(html); }); 二十四 无冲突 - noConflict 返回目录 当 jQuery 和其他的 JavaScript 框架同时将$作为简写的使用，可以考虑使用noConflict()方法解决冲突。 二十五 jQuery 实例 返回目录 总结前面的 jQuery 实例：https://www.runoob.com/jquery/jquery-examples.html 二十六 选择器扩展 返回目录 选择器的扩展大全 26.1 基本选择器 返回目录 $(\"#id\") // ID选择器 $(\"div\") // 元素选择器 $(\".classname\") // 类选择器 $(\".classname,.classname1,#id1\") // 组合选择器 26.2 层次选择器 返回目录 $(\"#id>.classname \") // 子元素选择器 $(\"#id .classname \") // 后代元素选择器 $(\"#id + .classname \") // 紧邻下一个元素选择器 $(\"#id ~ .classname \") // 兄弟元素选择器 26.3 过滤选择器（重点） 返回目录 $(\"li:first\") // 第一个 li $(\"li:last\") // 最后一个 li $(\"li:even\") // 挑选下标为偶数的 li $(\"li:odd\") // 挑选下标为奇数的 li $(\"li:eq(4)\") // 下标等于 4 的 li $(\"li:gt(2)\") // 下标大于 2 的 li $(\"li:lt(2)\") // 下标小于 2 的 li $(\"li:not(#runoob)\") // 挑选除 id=\"runoob\" 以外的所有 li 26.3.1 内容过滤选择器 返回目录 $(\"div:contains('Runob')\") // 包含 Runob 文本的元素 $(\"td:empty\") // 不包含子元素或者文本的空元素 $(\"div:has(selector)\") // 含有选择器所匹配的元素 $(\"td:parent\") // 含有子元素或者文本的元素 26.3.2 可见性过滤选择器 返回目录 $(\"li:hidden\") // 匹配所有不可见元素，或 type 为 hidden 的元素 $(\"li:visible\") // 匹配所有可见元素 26.4 属性过滤选择器 返回目录 $(\"div[id]\") // 所有含有 id 属性的 div 元素 $(\"div[id='123']\") // id属性值为123的div 元素 $(\"div[id!='123']\") // id属性值不等于123的div 元素 $(\"div[id^='qq']\") // id属性值以qq开头的div 元素 $(\"div[id$='zz']\") // id属性值以zz结尾的div 元素 $(\"div[id*='bb']\") // id属性值包含bb的div 元素 $(\"input[id][name$='man']\") //多属性选过滤，同时满足两个属性的条件的元素 26.5 状态过滤选择器 返回目录 $(\"input:enabled\") // 匹配可用的 input $(\"input:disabled\") // 匹配不可用的 input $(\"input:checked\") // 匹配选中的 input $(\"option:selected\") // 匹配选中的 option 26.6 表单选择器 返回目录 $(\":input\") //匹配所有 input, textarea, select 和 button 元素 $(\":text\") //所有的单行文本框，$(\":text\") 等价于$(\"[type=text]\")，推荐使用$(\"input:text\")效率更高，下同 $(\":password\") //所有密码框 $(\":radio\") //所有单选按钮 $(\":checkbox\") //所有复选框 $(\":submit\") //所有提交按钮 $(\":reset\") //所有重置按钮 $(\":button\") //所有button按钮 $(\":file\") //所有文件域 二十七 插件扩展 返回目录 配合 jQuery 的插件，可以更好的进行工作。 27.1 jQuery Validate 返回目录 说明：jQuery Validate是在jQuery基础上扩展的为表单提供验证功能的插件。 网址：https://www.runoob.com/jquery/jquery-plugin-validate.html 27.2 jQuery Accordion 返回目录 说明：jQuery Accordion插件用于创建折叠菜单 网址：https://www.runoob.com/jquery/jquery-plugin-accordion.html 27.3 jQuery Autocomplete 返回目录 说明：jQuery Autocomplete插件根据用户输入值进行搜索和过滤 网址：https://www.runoob.com/jquery/jquery-plugin-autocomplete.html 27.4 jQuery Growl 返回目录 说明：jQuery Growl用户做消息提醒 网址：https://www.runoob.com/jquery/jquery-plugin-message.html 27.5 jQuery Password Validation 返回目录 说明：jQuery Password Validation 在jQuery Validation 的基础上扩展，专门对密码进行验证 网址：https://www.runoob.com/jquery/jquery-plugin-password-validation.html 27.6 jQuery Prettydate 返回目录 说明：jQuery Prettydate为表单提供验证功能 网址：https://www.runoob.com/jquery/jquery-plugin-prettydate.html 27.7 jQuery Treeview 返回目录 说明：jQuery Treeview提供无序灵活的可折叠树形菜单 网址：https://www.runoob.com/jquery/jquery-plugin-treeview.html jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/jQuery/jQuery-frequently-used.html":{"url":"JavaScript-library/jQuery/jQuery-frequently-used.html","title":"jQuery 工作常用解决方案 ✔","keywords":"","body":"jQuery 工作常用解决方案 Create by jsliang on 2018-11-4 10:37:33Recently revised in 2019-05-31 00:06:05 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 记录工作中，使用 jQuery、HTML、CSS 等技术的技巧，包括但不限于：rem 适配、css reset、活动边框、弹窗等。 比较琐碎，各取所需。 一 JavaScript 1.1 jQuery 引入 CDN： 1.2 双引号与单引号的使用规范 在平时的时候，能使用双引号就用双引号。 在拼接字符串的时候，使用单引号裹住。 1.3 移动端rem适配 直接在 index.html 中引用该 js 文件即可。 mobile-terminal-adaptation.js /* * 2018年7月25日10:38:23 * 移动端 rem 适配，px:rem = 100:1 * 该适配兼容 UC 竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度: maxWidth * 这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); 1.4 jQuery ajax 方法 1： $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); }); 方法2： $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { $(\"#search-name\").val() + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 1.5 URL加码及解码 加码： window.location = \"adslList.htm?name=\" + escape(name) + \"&idNo=\" + escape(idNo); 解码： function getUrlParam(name) { var reg = new RegExp(\"(^|&)\"+ name +\"=([^&]*)(&|$)\"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } console.log(\"url name=\" + getUrlParam(\"name\") + \",url idNo=\" + getUrlParam(\"idNo\")); 1.6 常用正则表达式 知识点 1. 使用方式： if(!/^((\\d{8})|(1[35784]\\d{9}))$/.test($(\"#user-phone\").val())){ alert('请填写11位手机号码或8位固话号码'); return false; } 知识点 2. 密码强度 必须包含数字+小写字母+大写字母的密码，位数在8-10位之间： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 只能是字母、数字和下划线： ^\\w+$ 知识点 3. 校验中文： ^[\\u4e00-\\u9fa5]{0,}$ 知识点 4. Email验证： [\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 知识点 5. 身份证验证 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 知识点 6. 手机号验证：以1开头，第二位数是3/4/5/7/8的11位手机号码 ^1[3,4,5,7,8]\\d{9}$ 二 HTML 2.1 搜索跳转到百度 皮皮虾我们溜 三 CSS 3.1 设置input的placeholder reset.css /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #727272; } /* Webkit browsers */ input::-moz-placeholder { color: #727272; } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #727272; } /* Internet Explorer */ 3.2 使图片根据不同设备自适应 reset.css /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; } 3.3 垂直居中 首先，父元素设置relative； 然后，需要定位的元素设置absolute； 最后，垂直居中的top为50%，margin-top为该元素高度的负一半的高度值。 .search-result-area { position: relative; padding: 0 36px; } .previous-page, .next-page { position: absolute; top:50%; margin-top: -36px; } .previous-page { left: 0; } .next-page { right: 0; } 3.4 左右两栏布局 div1不变，div2浮动，div2的margin-left为div1的宽度。 div1+div2浮动，父级overflow=hidden。 父级relative定位，子级absolute定位。 3.5 css reset /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ 3.6 li前面点换成图片 ul{ list-style-image: url(img/5.jpg); } 3.7 制作div的边框 .content:before { content: \" \"; display: block; width: 100%; height: 3.46rem; background: url(\"../images/mobile-frame-top.jpg\") no-repeat center; background-size: 100%; position: absolute; left: 0; top: 0; z-index: 9; } .content { position: relative; background: url(\"../images/mobile-frame-content.jpg\") repeat-y center; background-size: 100% auto; width: 10rem; padding: 3.46rem 1.37rem 2.26rem; font-size: .3rem; } .content:after { content: \" \"; display: block; width: 100%; height: 2.26rem; background: url(\"../images/mobile-frame-bottom.png\") no-repeat center; background-size: 100%; position: absolute; left: 0; bottom: 0; z-index: 9; } 3.8 手机端背景图不能正确放大 .banner { background: url(\"../images/banner.jpg\") no-repeat; background-size: 100% auto; } 3.9 position情况下居中 left 值计算：width - button宽度一半 3.10 jsliang的弹窗 如果希望弹窗不固定大小，在手机端或者 PC 端都能使用，推荐使用百分比配置。 *.html 该板块暂未开放~ 好的，我知道了 *.css /** 弹窗 - alert **/ .jsliang-prompt { display: none; } .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; filter: alpha(opacity=30); -ms-filter: \"alpha(opacity=30)\"; opacity: .3; } .jsliang-alert { z-index: 999; position: fixed; top: 30%; left: 40%; width: 320px; height: 220px; box-shadow: 2px 2px 4px #A0A0A0, -2px -2px 4px #A0A0A0; background-color: #fff; padding: 25px; border-radius: 15px; text-align: center; } .jsliang-alert img { width: 120px; height: 83.8px; } .jsliang-alert p { margin-top: 10px; } .jsliang-get-it { color: #fff; background: #5bc0de; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143em; white-space: nowrap; cursor: pointer; border-color: #46b8da; border: 1px solid transparent; border-radius: 4px; text-align: center; vertical-align: middle; text-decoration: none; } .jsliang-get-it:hover { background: #31b0d5; } /* end */ 3.11 常用SVG 直接引用到页面即可。 3.12 滚动条 http://www.xuanfengge.com/demo/201311/scroll/css3-scroll.html 3.13 修改select样式 *.html 请选择商铺区域 香洲 拱北 前山 横琴 斗门 金湾 *.css .activity-area-select { width: 4.3rem; height: .6rem; line-height: .6rem; margin-left: .5rem; border: 1px solid #e0e0e0; border-radius: .28rem; font-size: .24rem; float: left; } /* 修改浏览器默认select */ .activity-area-select select { /* 清除边框 - Chrome和Firefox里面的边框不一样，需要复写 */ border: none; /* 清除聚焦颜色 */ outline: none; /* 清除默认样式 */ appearance: none; -moz-appearance: none; -webkit-appearance: none; /*在选择框的最右侧中间显示小箭头图片*/ background: url(\"../images/icon-select.png\") no-repeat center right scroll transparent; /*为下拉小箭头留出一点位置，避免被文字覆盖*/ padding-left: .3rem; padding-right: 2rem; } /* 清除边框 - 清除ie的默认选择框样式清除，隐藏下拉箭头*/ .activity-area-select select::-ms-expand { display: none; outline: none; } 3.14 修改table样式 *.html 商铺名称 商铺地址 珠海粤西贸易有限公司 珠海市香洲区群华路44号（五洲康城） 珠海市香洲阑山唯佳生鲜馆 香洲区南福路199号商铺 *.css .search-result-table { border:solid #e1e1e1; border-width:1px 0px 0px 1px; } table thead, tbody tr { display: table; width: 100%; table-layout: fixed; } .search-result-table tr:nth-child(2n+2) { background: #fff7ef; } .search-result-table th { background: #ffa751; color: #fff; font-size: .24rem; height: .63rem; line-height: .63rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } .search-result-table tbody { display: block; height: 6.05rem; overflow-x: hidden; overflow-y: scroll; } .search-result-table td { font-size: .22rem; height: .9rem; padding-left: .22rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } 四 Other 4.1 VSCode 选中设置 文件 -> 设置 -> User Settings -> editor.wordSeparators 下划线选中： `~!@#$%^&*()-=+[{]}\\\\|;:'\\\",.<>/? 横杠选中： ./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`~? 4.2 浏览器前缀参照 -moz- 对应 Firefox, -webkit- 对应 Safari and Chrome -o- 对应 Opera -ms- 对应 Internet Explorer 4.3 git的使用 本地仓库上传到GitHub： git init git add . git commit -m \"first commit\" git remote add origin https://github.com/address git push -u origin master 更新本地仓库到GitHub git add . git commit -m \"更新\" git push -u origin master 拉取GitHub项目到本地 git clone address 4.4 VS Code 设置模板页 安装插件 HTML Snippets 文件-首选项-用户代码片段-HTML 修改文件内容为：{ // Place your snippets for html here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } \"!!\": { \"prefix\": \"!!\", \"body\": [ \"\", \"\", \"\", \"\\t\", \"\\t\", \"\\t\", \"\\tHelloWorld\", \"\", \"\", \"\\t$1\", \"\\t\", \"\\t\", \"\", \"\" ], \"description\": \"!! - Defines a template for a html5 document\" } } 在 HTML 页面输入！！然后回车，即可看到新效果 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/ECharts/":{"url":"JavaScript-library/ECharts/","title":"ECharts","keywords":"","body":"ECharts Create by jsliang on 2018-11-28 10:53:08Recently revised in 2019-05-31 16:39:37 Echarts + Vue 折腾。 目录 目录 ECharts 打造在线个人简历 ECharts 打造在线个人简历 【升级版】 ECharts + Vue 折腾记 一 前言 ECharts 官网 ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 二 简介 2.1 丰富的可视化类型 ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。 除了已经内置的包含了丰富功能的图表，ECharts 还提供了自定义系列，只需要传入一个renderItem函数，就可以从数据映射到任何你想要的图形，更棒的是这些都还能和已有的交互组件结合使用而不需要操心其它事情。 你可以在下载界面下载包含所有图表的构建文件，如果只是需要其中一两个图表，又嫌包含所有图表的构建文件太大，也可以在在线构建中选择需要的图表类型后自定义构建。 2.2 多种数据格式无需转换直接使用 ECharts 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，通过简单的设置 encode 属性就可以完成从数据到图形的映射，这种方式更符合可视化的直觉，省去了大部分场景下数据转换的步骤，而且多个组件能够共享一份数据而不用克隆。 为了配合大数据量的展现，ECharts 还支持输入 TypedArray 格式的数据，TypedArray 在大数据量的存储中可以占用更少的内存，对 GC 友好等特性也可以大幅度提升可视化应用的性能。 2.3 千万数据的前端展现 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量，并且在这个数据量级依然能够进行流畅的缩放平移等交互。 几千万的地理坐标数据就算使用二进制存储也要占上百 MB 的空间。因此 ECharts 同时提供了对流加载（4.0+）的支持，你可以使用 WebSocket 或者对数据分块后加载，加载多少渲染多少！不需要漫长地等待所有数据加载完再进行绘制。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/ECharts/curriculum-vitae.html":{"url":"JavaScript-library/ECharts/curriculum-vitae.html","title":"ECharts 打造在线个人简历 ✔","keywords":"","body":"ECharts 打造在线个人简历 Create by jsliang on 2018-12-5 11:48:56Recently revised in 2019-05-31 19:16:24 Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 互联网冬天？裁员？跳槽？ 最近频繁听身边朋友说公司裁员、员工跳槽的事情，然后帮几个还没毕业的小师弟修改了几份简历，结果嘛，enmmm...... 咱使用 Vue + ECharts + ElementUI 来打造份在线个人简历，并将它部署到免费的服务器上去吧！ 最终成品线上地址：点击查看 涉及技术： Vue Vue-Router ECharts ElementUI HTML/HTML5 CSS/CSS3 JavaScript/ES6 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 整体搭建  3.1 基础配置  3.2 安装 ECharts  3.3 安装 ElementUI  3.4 总体配置 四 分步实现  4.1 part1 - 基本信息  4.2 part2 - 好友分布  4.3 part3 - 技能特长  4.4 part4 - 文章成就  4.5 part5 - 工作经验  4.6 part6 - 编程技能  4.7 part7 - 求职意向 五 总结 二 前言 返回目录 在使用 Vue + ECharts 编写公司报表项目的时候，突如其来有个 idea，想到好像可以写个在线简历。 于是，就去做了。 文章中的见解仅代表个人观点，不代表 “最优想法”，请文明评论、科学参考。 如有更好建议，可加 jsliang 的文档库 QQ 群讨论：798961601。 谢谢~ 三 整体搭建 返回目录 工欲善其事，必先利其器。 在我们进行愉快折腾之前，我们需要将代码的环境搭建好，才能如鱼得水，更好地开发。 3.1 基础配置 返回目录 首先，我们在指定目录下，通过控制台（终端）新建一个 Vue-Cli 项目： vue init webpack 然后，我们使用 npm i 安装 Vue-Cli 的依赖，生成 node_modules 文件夹。 最后，我们引入 CSS reset，并清理下红框内文件，之后项目变为如下所示： 此刻我们的一些文件发生了变动： HelloWorld.vue export default { name: 'HelloWorld', data () { return { } } } App.vue export default { name: 'App' } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' new Vue({ el: '#app', router, components: { App }, template: '' }) reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */ 当然，怕小伙伴们嫌麻烦，不想敲代码。 所以 jsliang 直接上传了基础代码，需要的小伙伴直接下载即可： ECharts 打造在线个人简历分支 - 基础配置 3.2 安装 ECharts 返回目录 既然说了用 ECharts 来写，那么，我们肯定要搞下 ECharts 的安装啦~ 首先，我们在项目中安装 ECharts 依赖： npm i echarts -S 然后，你可以选择按需引用还是全局引用（个人建议使用按需引用）： 全局引用 ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用 如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，是因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } }; 最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可： 当然，仅仅带进门，可能小伙伴们还可能会感觉懵逼：下一步我要怎么做？ 所以，jsliang 顺带讲讲 ECharts 如何上手： 照着上面案例敲一遍 过一遍它的上手文档：5 分钟上手 ECharts 查看它的各种实例，并从自己要做的简单的图做起 在步骤 3 中，碰到不懂的属性值，记得随时查看文档：文档 - 配置项手册 如此，小伙伴们就可以更好上手 ECharts 啦~ 3.3 安装 ElementUI 返回目录 考虑到 UI 是我，开发还是我。 那么，尽情使用 UI 框架吧！这里偷懒用 ElementUI 咯。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 安装 ElementUI：npm i element-ui -S 安装 babel-plugin-component：npm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js ```js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' }) 这样，就可以在项目中使用这两个组件了： > 项目/src/components/HelloWorld.vue 代码片段 111 222 333 ``` ![图](../../public-repertory/img/js-ECharts-CurriculumVitae-4.png) ### 3.4 总体配置 > [返回目录](#catalog-chapter-three-four) 该需要的东东，都差不多准备好了。 那么，我们的简历，长啥样呢？ 由于手里木有成品 “参考” 和 “借鉴”，所以去网上看看别人的 ECharts 都长啥样吧： ![图](../../public-repertory/img/js-ECharts-CurriculumVitae-5.png) 如图，**jsliang** 觉得这图的布局不错，所以下载下来了它的 png 版本和 psd 版本。 然后，怕小伙伴们难以想象要怎么操作，我用 PS 修改下它的 psd 吧： ![图](../../public-repertory/img/js-ECharts-CurriculumVitae-6.png) 很好，这个在线个人简历要怎么做就一目了然了。 下面我们开始切图仔工作： **首先**，创建 7 个 `components`，并删除 `HelloWorld.vue`： ![图](../../public-repertory/img/js-ECharts-CurriculumVitae-7.png) **jsliang** 太懒，名字就懒得想了，从左到右，从上到下，依次命名 7 个框的名字为 `PartOne` 到 `PartSeven` 吧。 > PartOne.vue 代码示例 ``` 第一部分 export default { } > 说到这里，有的小伙伴可能觉得复制粘贴或者手写 Vue-Cli 代码特别烦，所以这里推荐使用 VS Code 的插件：`Vue VSCode Snippets`。通过在页面上敲：`vbase`，就可以快速生成 Vue-Cli 的基础代码了。 **然后**，我们在 `index.js` 中定义这些文件，并在 `App.vue` 引用它们： > 项目/src/router/index.js ```js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) const PartOne = () => import('@/components/PartOne'); const PartTwo = () => import('@/components/PartTwo'); const PartThree = () => import('@/components/PartThree'); const PartFour = () => import('@/components/PartFour'); const PartFive = () => import('@/components/PartFive'); const PartSix = () => import('@/components/PartSix'); const PartSeven = () => import('@/components/PartSeven'); export default new Router({ routes: [ { path: '/', components: { PartOne: PartOne, PartTwo: PartTwo, PartThree: PartThree, PartFour: PartFour, PartFive: PartFive, PartSix: PartSix, PartSeven: PartSeven } }, { path: '/PartOne', name: 'PartOne', component: PartOne }, { path: '/PartTwo', name: 'PartTwo', component: PartTwo }, { path: '/PartThree', name: 'PartThree', component: PartThree }, { path: '/PartFour', name: 'PartFour', component: PartFour }, { path: '/PartFive', name: 'PartFive', component: PartFive }, { path: '/PartSix', name: 'PartSix', component: PartSix }, { path: '/PartSeven', name: 'PartSeven', component: PartSeven }, ] }) 项目/src/App.vue export default { name: 'App' } 此时，通过 npm run dev，我们可以在 localhost:8080/#/ 中可以看到我们已成功进行了布局： 最后，我们通过 CSS 的渲染，成功实现我们的总体布局： 此刻的项目结构图： App.vue export default { name: \"App\", data() { return { bannerXSSM: require(\"./assets/img/banner_640.png\"), bannerMD: require(\"./assets/img/banner_1000.png\"), bannerLGXL: require(\"./assets/img/banner.png\"), }; } }; body { background: #011128; color: #fff; } .app { width: 100%; } .part { padding: 20px; } .banner img { width: 100%; height: 80px; } p { text-align: center; } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入 ElementUI 响应式断点 import 'element-ui/lib/theme-chalk/display.css'; // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' }) PartOne.vue ( PartTwo 及其他 6 个文件雷同) 第一部分 export default { name: \"partOne\" }; .part-one { width: 100%; height: 500px; border: 15px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 这样，我们就成功完成了高尚的切图仔工作，可以继续下一步咯： 为了防止小伙伴们晕乎，保险起见 jsliang 将总体配置的代码提交到了分支，需要的小伙伴直接下载即可： ECharts 打造在线个人简历分支 - 完整配置 四 分步实现 返回目录 提问：简历一般有什么内容？ 回答： 基本信息：姓名、工作年限、学历、格言、年龄、联系电话、电子邮箱、GitHub、掘金…… 求职意向：职位、城市、薪资、准备入职时间…… 工作经验：…… 个人技能：熟悉 HTML5、CSS3、JavaScript…… 教育背景/荣誉证书（这两样没有很出彩的地方的话，jsliang 建议就忽略不写了） 所以，我们就着这几方面来编写我们的简历吧~ 4.1 part1 - 基本信息 返回目录 话不多说，先上代码： PartOne.vue 姓&emsp;&emsp;名：梁峻荣 学&emsp;&emsp;历：本科 工作年限：1 年 年&emsp;&emsp;龄：23 联系电话：18818881888 电子邮箱：1741020489@qq.com 博&emsp;&emsp;客：jsliang.top 掘&emsp;&emsp;金：jsliang GitHub：LiangJunrong export default { name: \"partOne\", data() { return { headImage: require('../assets/img/head_image.png') } } }; a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } p { line-height: 30px; } .part-one { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; padding-left: 10px; } .part-one-image { width: 150px; height: 150px; } 实现效果： 如上，这只是个简单的信息填充，就不多说了。 4.2 part2 - 好友分布 返回目录 话不多说，先上代码： PartTwo.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引用中国地图 require(\"echarts/map/js/china.js\"); export default { name: \"partTwo\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-two\")); // 排行前五城市 let myFirendCity = [ { name: \"广州\", value: [\"113.23\", \"23.16\", \"9\"] }, { name: \"深圳\", value: [\"114.07\", \"22.62\", \"12\"] }, { name: \"上海\", value: [\"121.48\", \"31.22\", \"10\"] }, { name: \"西安\", value: [\"108.95\", \"34.27\", \"4\"] }, { name: \"北京\", value: [\"116.46\", \"39.92\", \"12\"] }, ]; // 好友分布省份 let myFriendProvince = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 10 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ]; myChart.setOption({ // 标题 title: { text: \"前端好友分布\", textStyle: { color: \"#fff\" }, subtext: \"微信统计\", subtextStyle: { color: \"#fff\" }, x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 鼠标移动过去显示 formatter: function(params) { if (params.value[2] == undefined) { if(!params.name) { return \"该地区暂无好友\"; } else { return params.name + \" : \" + params.value; } } else { return params.name + \" : \" + params.value[2]; } } }, // 左边注记 visualMap: { text: [\"\", \"好友数\"], min: 0, max: 30, // 是否能通过手柄显示 calculable: true, inRange: { color: [\"#e4e004\", \"#ff5506\", \"#ff0000\"] }, textStyle: { color: \"#fff\" } }, // geo geo: { map: \"china\" }, // 数据 series: [ // 排行前五城市 { name: \"排行前五\", type: \"effectScatter\", coordinateSystem: \"geo\", symbolSize: function(val) { return val[2] * 2; }, showEffectOn: \"render\", rippleEffect: { brushType: \"stroke\" }, hoverAnimation: true, label: { normal: { formatter: \"{b}\", position: \"right\", show: true, color: \"#fff\" } }, itemStyle: { normal: { color: \"#ddb926\", shadowBlur: 10, shadowColor: \"#333\" } }, // 类似于 z-index zlevel: 1, data: myFirendCity, }, // 好友分布省份 { name: \"好友数\", type: \"map\", mapType: \"china\", // 是否允许缩放 roam: false, label: { // 显示省份标签 normal: { formatter: myFirendCity, show: false, textStyle: { color: \"#fff\" } }, // 对应的鼠标悬浮效果 emphasis: { show: false } }, itemStyle: { normal: { borderWidth: 0.5, // 区域边框宽度 borderColor: \"#fff\", // 区域边框颜色 areaColor: \"deepskyblue\" // 区域颜色 }, // 对应的鼠标悬浮效果 emphasis: { borderWidth: 1, borderColor: \"#fff\", areaColor: \"#00aeff\" } }, // 数据 data: myFriendProvince } ] }); } } }; .part-two { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 实现效果： 首先，我们引用了 ECharts 及它的中国地图： let echarts = require(\"echarts/lib/echarts\"); require(\"echarts/map/js/china.js\"); 然后，我们初始化 DOM 和数据： let myChart = echarts.init(document.getElementById(\"part-two\")); let myFriendData = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 5 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ]; 最后，我们通过 setOption 实现了地图的描绘，上面配置仅是个人配置方法，详细的方法请参考：ECharts 配置。 4.3 part3 - 技能特长 返回目录 说到简历，还记得之前看过一份，印象特深，因为人家就是用 Word 中用图表展示的。所以，咱也试试： PartThree.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partThree\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-three\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"技能分布图\", // 标题样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 显示文字样式 formatter: \"{a} {b} : {d}%\" }, // 注记 legend: { x: \"center\", y: \"bottom\", textStyle: { color: \"#fff\" }, data: [ \"HTML5\", \"CSS3\", \"JavaScript\", \"jQuery\", \"Vue\", \"Node\", \"微信小程序\", \"其他\" ] }, // 注记显示手柄 calculable: true, // 图形系列 series: [ { name: \"技能分布\", type: \"pie\", radius: [30, 110], roseType: \"area\", data: [ { value: 15, name: \"HTML5\" }, { value: 15, name: \"CSS3\" }, { value: 20, name: \"JavaScript\" }, { value: 20, name: \"jQuery\" }, { value: 20, name: \"Vue\" }, { value: 15, name: \"Node\" }, { value: 25, name: \"微信小程序\" }, { value: 15, name: \"其他\" } ] } ], // 颜色调整 color: ['#00bfff', '#00ffdd', '#207ffc', '#00aeff', \"#00eeff\", \"#006eff\", \"#0099ff\", \"#0066ff\"] }); } } }; .part-three { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 如上，我们就设置好了： 4.4 part4 - 文章成就 返回目录 有时候就是想偷懒，也想不起自己还有啥好吹水的了，于是贴个自己的前端文档库的成就吧： PartFour.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partFour\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-four\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"文章成就统计\", // 标题文本样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 图形布局 grid: { // 距离底部高度 bottom: \"20\" }, // 横轴 xAxis: { show: false, type: \"category\", data: [\"Github 提交：\\n1141\", \"Github Star数：\\n269\", \"掘金点赞量：\\n1508\", \"掘金关注者：\\n234\"], axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 纵轴 yAxis: { type: \"value\", axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 图形系列 series: [ { // 图类型 type: \"bar\", // 数据 data: [1141, 269, 1508, 234], // 文本 label: { show: true, position: \"top\", color: \"#fff\", formatter: \"{b}\" }, // 柱条样式 itemStyle: { color: \"deepskyblue\" }, zlevel: 1 } ] }); } } }; .part-four { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 4.5 part5 - 前端研发 返回目录 简历一大重点，就是工作经验啦： PartFive.vue 工作经验 广州**科技股份有限公司 | 2018/05 - 至今 工作内容：日常操作 jQuery 编写活动页、微信小程序、Vue + ECharts 报表制作…… 项目成就： &emsp;1. 企业宝小程序。使用原生代码进行微信小程序的开发，代码已完成，尚在审核，尚未上线。 &emsp;2. ECharts 报表汇总。使用 Vue + ECharts 进行报表设计，正在开发。 &emsp;3. jQuery 活动页及 H5 活动页。 export default { name: \"partFive\", data() { return { partFive: \"part-five\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } .part-five { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-five-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: 0.9em; color: rgb(253, 239, 239); } 结果显示为： 4.6 part6 - 编程技能 返回目录 除了工作经验，我们还需要 show 一下我们的编程技能都有什么： PartSix.vue 编程技能 前端：HTML/HTML5、CSS/CSS3、JS/ES6、jQuery、Vue、微信小程序…… 后端：Node、PHP 其他：MongoDB、MySQL、Sqlserver export default { name: \"partSix\", data() { return { partSix: \"part-six\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-six { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-six-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .font-small { font-size: .9em; } .font-bold { font-weight: bold; color: deepskyblue; } 成果如下图所示： 4.7 part7 - 求职意向 返回目录 最后，当然要表明我们的求职意向，好让 HR 小姐姐知道我们想要什么啦~ PartSeven.vue 求职意向 期望职位：前端工程师 工作技能：Vue 目标城市：广州、深圳、杭州、上海 期望薪资：10K - 15K 入职时间：随时入职 export default { name: \"partSeven\", data() { return { partSeven: \"part-seven\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-seven { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-sevev-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: .9em; } .font-bold { text-align: center; color: deepskyblue; } 结果如下图所示： 至此，所有代码编写完毕，偷懒的小伙伴可以去下面地址下载所有代码： ECharts 打造在线个人简历 五 总结 返回目录 最后再看下我们的最终成品： OK，到这里，这篇文章就结束啦！ 番外： 哈哈，jsliang 已经 预 感 到 了： 你的好友喷子小哥上线啦！ “哇，这样用 ECharts 的吗？还能不能更 low 点？！” “哇，Vue 这样写的吗？你懂不懂 Vue？” “哇，……” enm......所以我不管怎么说，都说不过这些大佬的，所以有的评论就不回复啦，哈哈~ 最后，在此祝小伙伴们找到更好的工作~ 小伙伴们如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/ECharts/curriculum-vitae-improve.html":{"url":"JavaScript-library/ECharts/curriculum-vitae-improve.html","title":"ECharts 打造在线个人简历 【升级版】 ✔","keywords":"","body":"ECharts 打造在线个人简历 【升级版】 Create by jsliang on 2018-12-11 10:21:27Recently revised in 2019-05-31 16:28:23 在发表文章 ECharts 打造在线个人简历 （GitHub版 / 掘金版） 后，迎来了各位大佬的吐槽： 根本没有一点技术含量，体现不出较高的前端水准。 可以用 Canvas 做动态背景么？应该会更炫酷。 百度的 AntV 也不错，值得一试。 边框能不能更炫酷点，用 CSS3 的动画来实现。 GitHub 的 start 数和掘金的点赞数能不能用爬虫爬出来啊，这样会不会更牛逼点。 综上，我决定结合这些建议，将它化为可行性，再升级打造过！ …… …… …… 才怪咧！jsliang 稳食艰难，抽不出功夫啊~ 目前正在折腾这两篇文章： Node 基础：从 0 到 1 打造 Node 扎实基础，实现 Web 服务的部署以及仿 Express 深入了解 Node 以及使用原生 Node 编写个简单的企业网站。 JavaScript 之 构造函数与原型对象：进一步深入了解，加深 JavaScript 的学习及使用。 同时，愁着下面两点： 写文章耗时。基本是：写文章时间 = 学习敲代码的时间 * 1.5。因为我不仅要自己懂，还要化繁为简，讲得小伙伴们也懂，我也印象深刻点。 明年想跳槽换 10K+ 的工作。但是时间不够，技术没法沉淀，现在在朝着自己 8 月份布的局，努力学习提升中，毕竟资本提不上去没资格跟 HR 要更好的薪资。 所以，除非有 特殊安排，要不在线简历这块是没那么快更新的咯，哈哈~ 最后的最后，引用我之前那句话： 不折腾的前端，和咸鱼有什么区别 相信按奈不住的小伙伴，可以根据 jsliang 的文章，结合上面更改的建议，自己动手搞个更炫酷的简历的，加油~ 更多精彩，尽在 jsliang 的文档库 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/ECharts/ECharts-Vue.html":{"url":"JavaScript-library/ECharts/ECharts-Vue.html","title":"ECharts + Vue 折腾记 ✔","keywords":"","body":"ECharts + Vue 折腾记 Create by jsliang on 2018-11-28 11:01:39Recently revised in 2019-05-31 16:30:08 Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 技术官网就是躺坑的地儿！ 翻遍百度文，一把辛酸泪~ 整合网上的 Vue + ElementUI，Vue + ECharts，ECharts + 百度地图 API……的文章，带你走非一般的道路。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 Vue  3.2 Echarts  3.3 ElementUI  3.4 百度地图 四 精细入微  4.1 百度地图调整  4.2 样式问题集 二 前言 返回目录 现在是大数据和云计算的时代，所以数据可视化逐渐变成一种趋势。 而 ECharts 对于制作的图表可以满足小伙伴们的创造力，它具备华丽的外衣，且实用。 在这里，jsliang 将通过 ECharts + Vue 进行折腾。 如果小伙伴们对 Vue 还不太熟，这里可能没法带你飞喔~前置条件：Vue、Npm、Webpack 参考文献： ECharts Demo | ECharts 官网 ElementUI | ElementUI 官网 在 vue-cli 项目中使用 echarts | 博客园 - 搞前端的李蚊子 Vue：在 Vue 中使用 echarts | 简书 - Mr_Treasure 在 VUE 项目中使用 ECharts 画 K 线图和面积图 | CSDN - zgh0711 在 vue 中添加 Echarts 图表使用详解 | PHP 中文网 - 小云云 v-charts | 饿了么 vue-echarts | npm 在 vue 中，应该直接使用 echarts 还是 vue-echarts | Vue 论坛 - JasonBai007 在 vue 项目中引入高德地图及其 UI 组件 | CSDN - shuaizi96 vue 引入高德地图 echarts 百度地图引用报错 A parser-blocking, cross site (i.e. different eTLD+1) script | CSDN - 雨中畅游 vue 引入公共css文件 | CSDN - Smartsunsing 调用百度地图api 去掉地图左下角LOGO或文字 | CSDN - 陈小黏 Echarts数据可视化系列文章 | CSDN - 数据架构师 几种css炫酷背景欣赏 | CSDN - 小圣贤君 三 正文 返回目录 Now, let's go~ 如果你觉得自己的 npm 下载速度过慢，请使用 cnpm： 安装：npm install -g cnpm --registry=https://registry.npm.taobao.org 使用：cnpm i 插件 -g 3.1 Vue 返回目录 Vue 参考文档： 介绍 Vue.js | Vue 官网 介绍 Vue Router | Vue Router 官网 步骤： 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 3.2 Echarts 返回目录 首先，我们在项目中安装 ECharts 依赖： npm i echarts -S 然后，你可以选择按需引用还是全局引用： 全局引用  ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用 如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } }; 最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可。 3.3 ElementUI 返回目录 考虑到项目没有 UI 设计稿。那么，就需要引用一款 Vue 的 UI 框架了，偷懒用 ElementUI 吧。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 步骤 1. 安装 ElementUI：npm i element-ui -S 步骤 2. 安装 babel-plugin-component：npm i babel-plugin-component -D 步骤 3. 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 步骤 4. 按需引入 Row 与 Col： main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' }) 这样，就可以在项目中使用这两个组件了。 3.4 百度地图 返回目录 引用百度地图很简单，但是结合 Vue + ECharts 来使用百度地图，很难。现在我们过一遍如何使用： 步骤 1. 引用百度地图： 项目/index.html ECharts 图表 注意：srcipt 引用的链接，需要你去百度地图 API 那里获得，因为 ak 对应的是个人的 API 地址，这里不可能泄露给你的。百度地图 API 步骤 2. 在组件中使用它： 模板表格 // 注意在 index.html 引入全局的百度地图 JS // script src=\"\"http://api.map.baidu.com/getscript?v=3.0&ak=Xjmh9v5jGa******6ZVf0PU2ueSedr5F\" // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入百度扩展 require(\"echarts/extension/bmap/bmap\"); export default { name: \"temp\", data() { return {}; }, mounted() { this.drawTempMap(); }, methods: { drawTempMap() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"temp-chart\")); // 创建地图实例 var map = new BMap.Map(\"temp-chart\"); // 绘制图表 myChart.setOption({ // 加载 bmap 组件 bmap: { // 百度地图中心经纬度 center: [116.46, 39.92], // 百度地图缩放 zoom: 4, // 是否开启拖拽缩放，可以只设置 'scale' 或者 'move' roam: true, // 百度地图的自定义样式，见 http://developer.baidu.com/map/jsdevelop-11.htm mapStyle: {} }, series: [ { type: \"scatter\", // 使用百度地图坐标系 coordinateSystem: \"bmap\", // 数据格式跟在 geo 坐标系上一样，每一项都是 [经度，纬度，数值大小，其它维度...] data: [ [116.46, 39.92, 1] ] } ] }); } } }; .temp-chart { width: 300px; height: 300px; } 这样，我们就可以在我们的 ECharts 畅通无阻地使用百度地图了。 四 精细入微 返回目录 有时候，一些小细节总会困惑你。 在这里，jsliang 将贴出自己解决的小细节。 结合 Ctrl + F 搜索关键字喔~ 4.1 百度地图调整 返回目录 问：为什么开发的时候控制台报 warning？ api?v=3.0&ak=Xjmh9v5jGa*****6ZVf0PU2ueSedr5F:1 A parser-blocking, cross site (i.e. different eTLD+1) script, http://api.map.baidu.com/getscript? 答： 这时候你的引用地址应该是： 你只需要将 api 改成 getscript 即可解决它的 warning 警告： 问：如何去除百度地图左下角的信息（logo 和 文字）？ 答：  你只需要在全局样式里写上下面这段话就可以屏蔽它： App.vue .BMap_cpyCtrl, .BMap_noprint, .anchorBL { display: none !important; } 4.2 样式问题集 返回目录 问：为什么 Chrome 上的 body 会有 8px 的 margin 值？或者 img 不贴边之类的。 答： 这是浏览器自带的样式喔，去掉方式： 首先，在项目的 static 目录上，新建 css 文件夹，然后新建 reset.css，内容如下所示： 项目/static/css/reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */ 然后，在项目目录的 src 目录下的 main.js 文件中添加下面的语句，就可以引用 css 样式，清空浏览器的内置了： 项目/src/main.js import '../static/css/reset.css' /**引入样式重置 */ Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/":{"url":"JavaScript-library/design-pattern/","title":"设计模式","keywords":"","body":"设计模式 create by jsliang on 2018-8-21 11:30:00Recently revised in 2019-05-31 17:01:56 一 目录 章节名 导航 第一章 部署开发环境 第二章 面向对象与设计模式初探 第三章 工厂模式 第四章 单例模式 第五章 适配器模式 第六章 装饰器模式 第七章 代理模式 第八章 外观模式 第九章 观察者模式 第十章 迭代器模式 第十一章 状态模式 第十二章 其他模式 第十三章 综合应用 其他模式中包含：原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式这 12 种不常用模式。 关于面试 面试中能说出第二章至第十一章的模式，一般来说设计模式方面是满分了，当然不排除是高级工程师，但是高级工程师是不会看我这篇文章的，所以 jsliang 就不担心被打脸了 关于工作日常使用 如果是常用的设计模式，最好就是结合自己的理解，列个列表，在工作中大胆尝试使用，而不是学习完就丢一边。如果是非常用的设计模式，那就应该视业务场景选择性使用。 二 使用场景 如果是业务性很强的，压根没时间写点好的JavaScript。一般来说，直接用面向对象写法，怎么方便怎么来。所以就有了“活动说明直接整张图丢上去，文字都也不弄出来”“能上图的就上图，写个文字都是罪” 然后，如果是长久使用的，要考虑维护的，还是用面向对象思路封装好来，随时调用。 三知识普及： Webpack： babel-core：把es6中的新语法（箭头函数、rest参数等）解析成ast这种形式，然后配合各个插件分析语法进行相应的处理。 babel-loader：一种loader解析器，配合Webpack解析ES6编写的js文件。 babel-preset-*：babel-reset-2015包含了es6对应的新语法，如果配置了babel-reset-latest，则包含了es2015、es2016、es2017的插件（之后可能包括es2018等）。注：在安装过程中jsliang发现，官方已不建议使用babel-preset-*系列了，而是推荐使用下面介绍的babel-preset-env包。 babel-polyfill：实现浏览器对不支持API的兼容（兼容旧环境、填补）。 babel-preset-env：如果不做任何配置，该loader等同于bable-preset-latest，如果你需要根据不同浏览器或者node版本进行配置，推荐使用babel-preset-env进行配置使用 详情介绍 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter01.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter01.html","title":"设计模式手册 - 1 - 部署开发环境 ✘","keywords":"","body":"设计模式手册 - 1 - 部署开发环境 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-31 17:09:27 第一章 部署开发环境 为什么要部署个开发环境呢？我就不能直接将 ES6 转成 ES5 直接使用吗？回答是：可以啊！链接拿去，里面告诉你怎么配置 babel，将 ES6 转 ES5。 如果你觉得还要配置 babel，也是挺麻烦的，链接拿去，里面已经设置好了，直接在线将 ES8、ES7、ES6 转 ES5，去吧少年~ 但是，怎么说呢，工欲善其事，必先利其器。一切的编程就是为了偷懒，所以 jsliang 配置个 Webpack 的 ES6 环境，就是想： 偷懒。每次写完代码按 Ctrl+C，就可以在另一个显示屏（jsliang 两个显示屏的）直接看到编译结果了，而不是用命令行将ES6转为ES5. 还是偷懒。有时候写个小项目，用原生搞的话，ES5 有时候写起来不爽啊，能耍耍 ES6 就好了，到时候还要搞事情，转 ES5、手机查看啥的，还不如直接配置好，到时候直接用啦。 还是还是偷懒。要知道有些个玩意，叫 vue-cli、react-cli、angular-cli，而且目前 jsliang 所知的，就是vue-cli是单页面SPA配置，到时候你要去搞多页面，还是需要学Webpack，所以事先学学，到时候就不用焦头烂额，又学react又搞Webpack啦~对了，顺带打个广告，Webpack的多页面配置jsliang已经配置好了，Webpack学习链接拿去、多页面配置链接拿去。 好嘞，jsliang强行解释一通，不管你接不接受，反正我是接受了，部署开发环境走起~ 1.1 打包JavaScript 本节实现目的：部署个能打包 JavaScript 的环境： 执行命令行：npm init -y，初始化package.json文件。 执行命令行：cnpm i webpack webpack-cli -D，安装webpack及其命令行工具webpack-cli。 在根目录下新建src文件夹，并在里面新建index.js文件，该文件打印了个100。 index.js console.log(100); 在根目录下新建webpack.dev.config.js文件。 webpack.dev.config.js module.exports = { entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, } 在webpack.dev.config.js中，我们做了两件事： 告知webpack我们的入口文件（需要被解析的ES6文件）在根目录的src下的index.js； 告知webpack我们的出口文件（被解析后的ES5文件）需要打包到的位置是相对于当前目录的dist/src下的index.js。 修改package.json文件。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", } } 在这里，我们修改了\"scripts\"部分，告知npm在npm run dev的时候，记得使用webpack命令，用开发模式来解析配置文件webpack.dev.config.js。 执行命令行：npm run dev，可以查看到在根目录中生成了个dist文件夹，该文件夹下存有一个src文件夹，里面包含了个index.js。本处有点小瑕疵，这里是src文件夹，但是到了后面变成了js文件夹，因为这是打包后的js存放的地方，当然这里是不影响使用的，下面我们会提到。 此时目前目录如下： 1.2 动态打包JavaScript  本节实现目的：部署个能按Ctrl+C，就能自动更新代码的Webpack环境。 执行命令行：cnpm i webpack-dev-server html-webpack-plugin -D，安装Webpack的devServer，这个能启动开发模式实时监控代码的webpack配置。同时，安装html-webpack-plugin，这个能解析HTML的插件。 新建dist/index.html文件，由于这个HTML文件无特殊之处，所以这里不做过多讲解： index.html jsliang的设计模式 jsliang的设计模式 根据我们安装的webpack-dev-server与html-webpack-plugin这两个配置，修改webpack.dev.config.js，使其能解析HTML文件和监控dist目录。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 //host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改package.json，告知npm，我们不用webpack这个比较low的方式了，请给我用webpack-dev-server来启动npm run dev。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 执行命令行：npm run dev，发现浏览器自动打开http://localhost:8080(启动WiFi的情况下应该是打开类似于http://192.168.1.107:8080/)的网址： 此时文件目录为： 1.3 自动打包ES6  本节实现目的：部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。 执行命令行：cnpm i babel-core babel-loader babel-polyfill babel-preset-env -D，安装ES6对应的解析配置，执行完毕后package.json会自动新增依赖包： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 新建.babelrc文件，该文件为ES6解析到ES5必须使用的文件（注，现在市面上大部分浏览器还不能完全直接解析ECMA Script2015语法，所以只能将ES6转为ES5，就用到了.babelrc文件）： .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } 修改webpack.dev.config.js，添加module，告知webpack在加载js文件的时候，需要使用babel-loader。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改index.js，这里我们换成ES6语法（如果你还没学过ES6，你只需要知道这里弹窗显示了jsliang即可，内容可以忽略）： index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); 执行命令行：npm run dev，即可看到HTML页面弹窗显示 jsliang 。 1.4 完善配置  本节实现目的：npm run dev命令下，部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。npm run build命令下，能打包文件到dist目录。 经过上面的努力，终于可以在多终端（电脑+手机）实时查看自己编写的ES6代码了。然而，还是有点小瑕疵。例如：无法将代码打包应用于生产；打包js的目录名称叫src……。所以，Let's Go! 再搞个生产环境，让我们完美结束这份Webpack配置吧~ 新增webpack.prod.config.js，用作打包生产： webpack.prod.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 修改下package.json，使其能使用命令行npm run build： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 完善下webpack.dev.config.js： wepbakc.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 检查下其他文件，看看是否与jsliang一致： src/index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } index.html jsliang的设计模式 jsliang的设计模式 执行命令行npm run dev或者npm run build,然后查看目录：OK，都能成功运行，生产环境部署完毕，接下来我们愉快地玩耍设计模式吧！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter02.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter02.html","title":"设计模式手册 - 2 - 面向对象 ✘","keywords":"","body":"设计模式手册 - 2 - 面向对象 create by jsliang on 2018年8月24日08:00:00Recently revised in 2019-05-20 17:31:39 未完善版，待完善。 第二章 面向对象 2.1 概念  什么是面向对象？大概1000个人有1001个解释。在这里，jsliang也不去做着1001种解释了，你看着烦我写着累，所以咱用大俗话强行解释一通，懂的就过了，不懂的还不查百度/Chrome就是你的过了。 说起面向对象，我们就要结合面向过程来说了。下面我们有一个游戏场景：  游戏过程： 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾往画面右边走了两步； 皮皮虾夹了下象拔蚌； 皮皮虾受到了象拔蚌的甩鞭反击； 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾发现状态不对，赶紧逃跑。  面向过程： 描绘一只皮皮虾，一个象拔蚌，一个战斗场景; 编写弹窗，显示皮皮虾状态; 编写动画，皮皮虾在游戏场景向右移动两步; 编写动画，皮皮虾攻击象拔蚌; 编写动画，象拔蚌攻击皮皮虾; 编写弹窗，弹窗显示皮皮虾状态; 编写动画，皮皮虾退出战斗场景； 编写动画，败北动画。  面向对象： 准备： 皮皮虾库。存放了皮皮虾的属性状态、动作…… 象拔蚌库。存放了象拔蚌的属性状态、动作…… 游戏场景库。存放了二维坐标、移动动画、战败场景、胜利场景…… 调用了皮皮虾的属性状态。 调用了皮皮虾的属性状态中的头像，调用了游戏场景库中的移动动画，传了两个二位坐标，皮皮虾从左移到右，顺带调用了皮皮虾的跑步动作。 调用了皮皮虾的攻击动作，耍出一套降象十八剪。 调用了象拔蚌的攻击动作，顺带调用了皮皮虾的受击动作。 调用了皮皮虾的属性状态。 调用了皮皮虾败北的动作，顺带调用了场景库的战败场景。  你可能会说，不对啊！面向对象还要做准备，这样不是比面向过程更复杂吗？如果你游戏就这么个场景，那么，使用面向对象就得不偿失了，毕竟做准备也要花功夫的。但是，如果你的游戏，还有火影大战海贼王，也是调用同样的游戏场景库，如果你使用面向过程，是不是要复制粘贴或者重新写过，但是面向对象只需要调用已经写好的游戏场景库，从而省下了大笔时间。 这么说你可能还迷糊，说了那么多话，面向对象究竟长啥样？别急，我们代码的世界见： class Person { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`) } } let jsliang = new Person(\"jsliang\"); jsliang.eat(); let JavaScriptLiang = new Person(\"JavaScriptLiang\"); JavaScriptLiang.speak();  在这段代码中，我们使用了封装了个Person的类（如果小伙伴你仅知道ES5，没见过ES6的语法，建议先去看下ES6），然后，jsliang调用了eat这个吃饭的动作，JavaScriptLiang调用了speak这个说话的动作，下次run()、sleep()这些我们也可以放进去，从而实现每个人都可以有属于自己的一套动作。这就是面向对象写法。 很好，经这么一说，jsliang算是勉强过了一遍什么是面向过程和面向对象了。如果小伙伴还是不懂，嗯，如果你没看到开篇那句话的话，那你还是不懂吧~先跟着jsliang撸一遍面向对象再说！ 2.2 三要素 2.2.1 继承  继承，简单来说，就是子类继承父类。继承可将公共方法抽离出来，提高复用，减少冗余。 //父类： 人类Person class People { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { constructor(name, age, id) { super(name, age); this.id = id; } study() { alert(`${this.name} ID is ${this.id}`); } } let jsliang = new People(\"jsliang\", 23); jsliang.speak(); // 在这里，子类学生继承了父类人类，学生既可以调用study()类 // 也可以调用父类中的eat()和speak() let studentLiang = new Student(\"jsliang\", 18, \"003\"); studentLiang.study(); studentLiang.eat(); 2.2.2 封装  封装，简单来说，就是数据的权限和保密。封装的作用有：1、减少耦合，不该外露的不外露；2、利于数据、接口的权限管理 封装有三个关键字：public(完全开放)、protected(对子类开放)、private(对自己开放)。 目前来说，ES6不支持封装，而TypeScript支持。所以，为了做到封装效果，我们可以约定下划线 _ 开头的属性是 private (实际不安全) //父类： 人类Person class People { public name; public age; protected weight; // 定义 protected 属性。受保护的，只有自己和其子类能访问，并且只能在类里面访问，外部调用不会成功 constructor(name, age) { this.name = name; this.age = age; this.weight = 120; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { public id; private girlfriend // 定义private属性 constructor(name, age, id) { super(name, age); this.id = id; this.girlfriend = 'xiaoli' //由于 girlfriend 字段是私有的，所以 People 无法获取，而且只有在 Student 这个类的内部才能访问，外部是无法知道的。但是会有个 bug ，如果你 New 出无数个学生，然后所有学生的女朋友都会叫 xiaoli ，但是这些学生不知道。 } study() { alert(`${this.name} ID is ${this.id}`); } getWeight() { alert(`$this.weight`); // 由于 weight 是受保护的，只有父类和继承它的子类能访问，所以学生类也可以访问体重。 } } let xiaoming = new Student('xiaoming', 10, '001'); xiaoming.getWeight(); alert(xiaoming.girlfriend); // 语法error,因为girlfriend是受保护的 2.2.3 多态  多态，同一接口不同实现。在JavaScript中应用极少，因为多态是需要结合后端语言的接口、重写、重载等功能。多态的优点：1、保持子类的开放性和灵活性；2、面向接口编程；3、JavaScript引用极少。 class People { constructor(name) { this.name = name; } saySomething() { alert(`Hello, my name is ${this.name}`); } } class A extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is A.`); } } class B extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is B`); } } let a = new A('a'); a.saySomething(); let b = new B('b'); b.saySomething();  在上面的例子中，我们可以看出，A 类继承了 People 类，同时，A 类重写了 saySomething() 方法，B 类也是如此，因而，做到了多态效果。 2.2.4 应用  jQuery是使用面向对象编写的。 class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i 2.3 设计原则 什么是设计？设计即是按照哪一种思路或者标注来实现功能。功能相同的代码，可以有不同设计方案来实现。如果仅仅是几行代码，设计可能会浪费时间。但是，伴随着需求的增加，设计的作用就体现出来了。 有哪些设计原则？ 准则1：小即是美。在一开始的时候，jQuery仅仅只有90KB左右。然后，到了Vue.js这边，就只剩30KB左右。而现在，听说有个6KB的js文件，能做到非常好的JavaScript性能。所以，将来的JavaScript一定会往小而精的方面发展，在内核小而美的基础上，发展周边生态。同时，我们的周边生态，一定是有意义的，有作用的，从而产生各部分之和大于它们的原集合，要不然我们就不需要对框架进行分离了，我们直接将周边生态内置于框架内就行了。我们不仅要做到JavaScript框架的小而美，在代码中，我们应该也尽量用精炼的单词，编写精简的代码。 准则2：让每个程序只做好一件事。代码不是万能钥匙，能开车，能开锁。我们的代码，最好能指定某某部分代码实现某个功能，做到分工合理。如果有部分代码，既可以画canvas，又可以操作dom，听起来很美好，实际上，当你接替上一任程序猿的时候，你要把它的具体功能实现猜一遍，它是做这件事的？还是那件事？同时，每个程序，如果是进行数字操作的，那么，就不应做弹窗返回个字符串之类的操作，以免造成混淆。 准则3：快速建立原型。编程界有个词，叫做敏捷开发。当客户提出一个需求的时候，如果你不先通过建立原型，满足用户的需求。随着时间迁移，客户可能会根据市场变化，而修改他原本的决定，从而导致你一直跟着客户变动。所以，在客户提出需求的一刻，我们应该快速建立原型，满足客户的基本需求，然后在进行深度开发。 准则4：舍弃高效率而取可移植性。如果你从事于某个具体行业，该行业可能做了大量的重复性工作。那么，你应该考虑，朝可移植性进行开发，虽然前期可能浪费一些效率，但是，后期的效率提升是值得拥有的。同时，我们在进行可移植性设计的时候，应该尽可能满足绝大多数用户的需求，避免为了极个别的用户，而抛弃大部队。如果花费20%的成本解决80%的需求，那么我们就是胜利的。如果为了20%的需求，浪费掉80%的成本，那么，我们就是失败的。 准则5：采用纯文本来存储数据。大部分人都知道，计算机只认识010101这个二进制数值，文本是二进制的升级版1，图片是二进制的升级版2，视频是二进制的升级版*……所以，越贴近二进制的东东，越小且越容易被计算机识别，因而我们推荐采用纯文本来实现数据存储。效率快存储方便。 准则6：避免强制性的用户界面。现在是以用户为主的时代。如果是00年以前，计算机流行不普遍的时候，强制用户接受某软件、某网站，可以轻松做到。但是，现在如果你的界面做得不好，你的功能开发地不完美，你又不去修改，那么，客户就会离你而去，因为你的竞争对手已经把你的问题给解决了。所以，我们应该避免强制性的用户界面，实现界面可调整，实现功能可定制化，允许用户定制环境，从而赢取更多的客户。 准则7：让每个程序都称为过滤器。 什么是5大设计原则？五大设计原则为：SOLID。 S - 单一职责原则：1、一个程序只做好一件事；2、如果功能过于复杂就拆分开，让每个部分保持独立。 O - 开放封闭原则：1、对扩展开放，对修改封闭；2、增加需求时，扩展新代码，而非修改已有代码；3、这是软件的终极目标。 L - 李？里氏替换原则：1、子类能覆盖父类；2、父类能出现的地方子类就能出现。 I - 接口独立原则：1、保持接口的单一独立，避免出现“胖接口”；2、JavaScript中没有接口（TypeScript例外），使用较少；3、类似于单一职责原则，这里更关注接口。 D - 依赖导致？倒置原则：1、面对接口编程，依赖于抽象而不依赖于具体；2、使用方只关注接口而不关注具体类的实现。  在设计原则中，S O 体现较多，详细介绍；而L I D 体现较少，但是需要了解其用意。 有没有具体例子？有的： // 加载图片 function loadImg(src) { var promise = new Promise(function (resolve, reject) { var img = document.createElement('img'); img.onload = function() { resolve(img); }; img.onerror = function() { reject('图片加载失败'); }; img.src = src; }); return promise; } var src = 'https://www.imooc.com/static/img/index/logo_new.png'; var result = loadImg(src); result.then(function(img) { // part1 console.log('ing.width', img.width); return img; }).then(function(img) { // part2 console.log('img.height', img.height); }).catch(function(ex) { // 统一捕获异常 console.log(ex); }) 在这里，实现了单一职责原则和开放封闭原则。 单一职责原则：每个 then 中的逻辑只做好一件事。 开放封闭原则：如果新增需求，扩展 then 。 对扩展开放，对修改封闭。 2.4 设计模式 何为设计？ 何为模式？ 如何从设计到模式？ 设计模式分为多少种？23种，大致可以分为创建型、组合型、行为型。 创建型：1、工厂模式（工厂方法模式，抽象工厂模式，建造者模式）；2、单例模式；3、原型模式 结构型：1、适配器模式；2、装饰器模式；3、代理模式；4、外观模式；5、桥接模式；6、组合模式；7、享元模式。 行为型-1：1、策略模式；2、模板方法模式；3、观察者模式；4、迭代器模式；5、职责连模式；6、命令模式。 行为型-2：1、备忘录模式；2、状态模式；3、访问者模式；4、中介者模式；5、解释器模式。 如何学习设计模式？ 明白每个设计的道理和用意； 通过经典应用体会它的真正使用场景； 编码时多思考，尽量模仿。 2.5 实例 题目一： 打车时，可以打专车或者快车。任何车都有车牌号和名称。 不同车价格不同，快车每公里1元，专车每公里2元。 行程开始时，显示车辆信息。 行程结束时，显示打车金额（假定行程就5公里）。  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 class Car { constructor(number, name) { this.number = number; this.name = name; } } class Kuaiche extends Car { constructor(number, name) { super(number, name); this.price = 1; } } class Zhuanche extends Car { constructor(number, name) { super(number, name); this.price = 2; } } class Trip { constructor(car) { this.car = car; } start() { console.log(`行程开始，名称： ${this.car.name}, 车牌号：${this.car.price}`); } end() { console.log(`行程结束，价格：` + (this.car.price * 5)); } } let car = new Kuaiche(100, '桑塔纳'); let trip = new Trip(car); trip.start(); // 行程开始，名称： 桑塔纳, 车牌号：1 trip.end(); // 行程结束，价格：5 题目二： 某停车场，分3层，每层100车位 每个车位都能监控到车辆的驶入和离开 车辆进入前，显示每层的空余车位数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 // 车辆 class Car { constructor(num) { this.num = num; } } // 入口 摄像头 class Camera { shot(car) { return { num: car.num, inTime: Date.now() } } } // 出口显示屏 class Screen { show(car, inTime) { console.log('车牌号', car.num); console.log('停车时间', Date.now() - inTime); } } // 停车场 class Park { constructor(floors) { this.floors = floors || []; this.camera = new Camera(); this.screen = new Screen(); this.carList = {}; // 存储摄像头拍摄返回的车辆信息 } in(car) { // 通过摄像头获取信息 const info = this.camera.shot(car); // 停到某个停车位 const i = parseInt(Math.random() * 100 % 100); const place = this.floors[0].places[i]; place.in(); info.places = place; // 记录信息 this.carList[car.num] = info; } out(car) { // 获取信息 const info = this.carList[car.num]; // 将停车位清空 const place = info.places; place.out(); // 显示时间 this.screen.show(car, info.inTime); // 清空记录 delete this.carList[car.num]; } emptyNum() { return this.floors.map(floor => { return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个空闲车位。`; }).join('\\n'); } } // 楼层 class Floor { constructor(index, places) { this.index = index; this.places = places || []; } emptyPlaceNum() { let num = 0; this.places.forEach(p => { if(p.empty) { num = num + 1; } }) return num; } } // 车位 class Place { constructor() { this.empty = true; } in() { this.empty = false; } out() { this.empty = true; } } // 测试 // 初始化停车场 const floors = []; for(let i = 0; i jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter03.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter03.html","title":"设计模式手册 - 3 - 工厂模式 ✘","keywords":"","body":"设计模式手册 - 3 - 工厂模式 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-20 17:34:16 第三章 工厂模式 3.1 使用介绍 将 new 操作单独封装。 遇到 new 时，就要考虑是否使用工厂模式。 举个例子：  你去购买汉堡，只需要跟服务员点餐，做汉堡这些步骤你就不用理会了。然后下一个人去购买汉堡，也是只需要点餐，至于餐厅怎么操作的，就不需要去关心了。在这里，餐厅封装了做汉堡的工作，只需要“接受点餐”、“送餐给顾客”就可以了。 3.2 UML类图及其实现 class Product { constructor(name) { this.name = name; } init() { alert(\"init\"); } fun1() { alert(\"fun1\"); } fun2() { alert(\"fun2\"); } } class Creator { create(name) { return new Product(name); } } // 测试 let creator = new Creator(); let p = creator.create(\"p1\"); p.init(); // init p.fun1(); // fun1 3.3 使用场景 jQuery - $(\"div\") React.createElement vue 异步组件 jQuery class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i React var profile = {[user.firstName, user.lastName].join(' ')} var profile = React.createElement(\"div\", null, React.createElement(\"img\", {src: \"avatar.png\", className: \"profile\"}), React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \")); ); class Vnode(tag, attr, children) { // ...省略内部代码... } React.createElement = function(tag, attrs, children) { return new Vnode(tag, attrs, children); } Vue Vue.component('async-example', function(resolve, reject) { setTimeout(function() { resolve({ template: 'I am async!' }) }, 1000) }) 3.4 设计原则验证 构造函数和创建者分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter04.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter04.html","title":"设计模式手册 - 4 - 单例模式 ✘","keywords":"","body":"设计模式手册 - 4 - 单例模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:58:32 第四章 单例模式 系统中被唯一使用 一个类只有一个实例 单例模式中需要用到private，而ES6中没有private，所以需要TypeScript 4.1 代码实现 class SingleObject { login() { console.log(\"login...\"); } } SingleObject.getInstance = (function() { let instance; return function() { if(!instance) { instance = new SingleObject(); } return instance; } })() // 测试：注意这里只能使用静态函数 getInstance ，不能 new SingleObject() !!! let obj1 = SingleObject.getInstance(); obj1.login(); // login... let obj2 = SingleObject.getInstance(); obj2.login(); // login... console.log(obj1 == obj2); // true （两者必须完全相等） 4.2 使用场景 jQuery 只有一个 $ ，这就是单例模式的一个例子 登录框 购物车 vuex 和 redux 中的 store jQuery单例模式 // jQuery 只有一个 '$' if (window.jQuery != null) { return window.jQuery; } else { // 初始化 } 如果引用了jQuery，那就不做任何操作；如果没有引用，那就初始化引用。 登录框模拟 class LoginForm { constructor() { this.state = \"hide\"; } show() { if(this.state === \"show\") { alert(\"已经显示\"); return; } this.state = \"show\"; console.log(\"登录框显示成功\"); } hide() { if(this.state === \"hide\") { alert(\"已经隐藏\"); return; } this.state = \"hide\"; console.log(\"登录框隐藏成功\"); } } LoginForm.getInstance = (function() { let instance; return function() { if(!instance) { instance = new LoginForm(); } return instance; } })(); let login1 = LoginForm.getInstance(); login1.show(); let login2 = LoginForm.getInstance(); login2.hide(); console.log(\"login1 === login2\", login1 === login2); // login1 === login2 true 4.3 设计原则验证 符合单一职责原则，只实例化唯一的对象 没法具体开放封闭原则，但是绝对不违反开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter05.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter05.html","title":"设计模式手册 - 5 - 适配器模式 ✘","keywords":"","body":"设计模式手册 - 5 - 适配器模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:36:14 第五章 适配器模式 旧接口格式和使用者不兼容 中间加一个适配转换接口 5.1 UML类图 5.2 代码实现 class Adaptee { specificRequest() { return \"德国标准的插头\"; } } class Target { constructor() { this.adaptee = new Adaptee(); } request() { let info = this.adaptee.specificRequest(); return `${info} -> 转换器 -> 中国标准的插头`; } } // 测试 let target = new Target(); console.log(target.request()); // 德国标准的插头 -> 转换器 -> 中国标准的插头 5.3 使用场景 封装旧接口 vue computed 封装旧接口 // 自己封装的 ajax ，使用方式如下： ajax({ url: 'getData', type: 'Post', dataType: 'json', data: { id: '123' } }).done(function() { }) // 由于历史原因，代码中全都是： // $.ajax({...}) // 做一层适配器 var $ = { ajax: function(options) { return this.ajax(options); } } vue computed Vue Computed 顺序： 逆序： var vm = new Vue({ el: \"#app\", data: { message: \"hello\" }, computed: { reversedMessage: function() { return this.message.split('').reverse().join(''); } } }) 5.4 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:14 "},"JavaScript-library/design-pattern/design-pattern-chapter06.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter06.html","title":"设计模式手册 - 6 - 装饰器模式 ✘","keywords":"","body":"设计模式手册 - 6 - 装饰器模式 create by jsliang on 2018年8月30日09:54:33Recently revised in 2019-05-20 17:36:50 第六章 装饰器模式 为对象添加新功能 不改变其原有的结构和功能 手机壳可以简单的看做是一个装饰器模式 6.1 UML类图 6.2 代码实现 class Circle { draw() { console.log(\"画一个圆形\"); } } class Decorator { constructor(circle) { this.circle = circle; } draw() { this.circle.draw(); this.setRedBorder(circle); } setRedBorder() { console.log(\"设置红色边框\"); } } // 测试代码 let circle = new Circle(); circle.draw(); // 画一个圆形 let dec = new Decorator(circle); dec.draw(); // 画一个圆形 // 设置红色边框 6.3 使用场景 ES7 装饰器：  ES7装饰器的三个步骤： npm install babel-plugin-transform-decorators-legacy -D 设置.babelrc配置 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] } 然后测试该配置是否生效： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec class Demo { } function testDec(target) { target.isDec = true; } alert(Demo.isDec); // true  在这里简化下装饰器语法： // 装饰器的原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 装饰类  在这里，我们还可以传参数： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec(false) class Demo { } function testDec(isDec) { return function(target) { target.isDec = isDec; } } alert(Demo.isDec); // false  然后，我们再根据mixin进行一个示例 function mixins(...list) { return function(target) { Object.assign(target.prototype, ...list); } } const Foo = { foo() { alert('foo') } } @mixins(Foo) class MyClass { } let obj = new MyClass(); obj.foo(); // foo 装饰方法  @readonly 只读属性 class Person { constructor() { this.first = \"A\"; this.last = \"B\"; } // 装饰方法 @readonly name() { return `${this.first} ${this.last}` } } function readonly(target, name, descriptor) { /** * descriptor 属性描述对象 (Object.defineProperty 中会用到)，原来的值如下： * { * value: specifiedFunction, * enumerable: false, * configurable: true, * writable: true * } */ descriptor.writable = false; return descriptor; } var p = new Person(); console.log(p.name()); // A B // 如果设置 p.name = function() {}; 这样子就会报错，因为 name 被我们设置为只读属性  例子2： class Math { // 装饰方法 @log add(a, b) { return a + b; } } function log(target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function() { console.log(`Calling ${name} with`, arguments); return oldValue.apply(this, arguments); }; return descriptor; } const math = new Math(); const result = math.add(2, 4); // 执行 add 时，会自动打印日志，因为有 @log 装饰器 console.log(\"result\", result); /** * Calling add with Arguments(2) [2, 4, callee: (...), Symbol(Symbol.iterator): ƒ] * result 6 */ 其实，上面的方法，都封装到第三方插件里面去了： core-decorators。这个是第三方开源的lib，提供了常用的装饰器。感兴趣的还可以拜读下官方说明：查看详情  使用 core-decorators 的方式 安装 core-decorators ： npm i core-decorators -S 然后开始编码： readonly： 只读 import { readonly } from 'core-decorators'; class Person { @readonly name() { return 'zhang'; } } let p = new Person(); alert(p.name()); // zhang depercate： 废弃的警告 // 废弃的 API import { deprecate } from 'core-decorators'; class Person { @deprecate faceplam() { } @deprecate(\"We stopped faceplaming\") faceplamHard() { } @deprecate(\"We stopped faceplaming\", {url: \"http://jsliang.top\"}) faceplamHarder() { } } let person = new Person(); person.faceplam(); // deprecate.js:31 DEPRECATION Person#faceplam: This function will be removed in future versions. person.faceplamHard(); // DEPRECATION Person#faceplamHard: We stopped faceplaming person.faceplamHarder(); // deprecate.js:31 DEPRECATION Person#faceplamHarder: We stopped faceplaming // See http://jsliang.top for more details.**** 6.4 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter07.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter07.html","title":"设计模式手册 - 7 - 代理模式 ✘","keywords":"","body":"设计模式手册 - 7 - 代理模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:38:16 第七章 代理模式 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 关于代理模式，可以简单理解下 国外网站。有些国外网站被墙了的，需要我们通过一些能访问国外站点的代理服务器去访问 公司网络。有些公司有自己的内容，如果我们在家要访问，那么就需要通过代理，才能访问到。 明星经纪人。如果你要找明星演戏，你是找不到本人的，这时候你需要找它的代理：经纪人。去详谈合作事务，谈妥当后经纪人会帮你转告明星，开始工作。 7.1 UML类图 7.2 代码演示  代理模式中，代理的类提供的接口必须跟被代理的类名一样。 class ReadImg { constructor(fileName) { this.fileName = fileName; this.loadFromDisk(); // 初始化即从硬盘中加载，模拟 } display() { console.log(\"display... \" + this.fileName); } loadFromDisk() { console.log(\"loading... \" + this.fileName); } } class ProxyImg { constructor(fileName) { this.realImg = new ReadImg(fileName); } display() { this.realImg.display(); } } // 测试 let proxyImg = new ProxyImg(\"1.png\"); proxyImg.display(); // loading... 1.png // display... 1.png 7.3 使用场景 网页事件代理 jQuery $.proxy 网页时间代理 HelloWorld a1 a2 a3 a4 a5 $(function() { var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(target.nodeName === \"A\") { alert(target.innerHTML); } }) }) $.proxy HelloWorld .red { color: green; } a1 a2 a3 a4 a5 Hello World! $(function() { $(\"#div1\").click(function() { var _this = this; setTimeout(function() { console.log(this); $(_this).css(\"background-color\", \"yellow\"); }, 1000) }) // 使用 $.proxy 解决，这样就少定义一个变量 $(\"#div2\").click(function() { // var fn = function() { // $(this).css(\"background-color\", \"yellow\"); // } // fn = $.proxy(fn, this); // setTimeout(fn, 1000); // 下面代码等效于上面代码 setTimeout($.proxy(function() { $(this).css(\"background-color\", \"yellow\") }, this), 1000); }) }) ES6 Proxy // 明星 let star = { name: \"张××\", age: 25, phone: 'star - 13910733521' } // 经纪人 let agent = new Proxy(star, { get: function(target, key) { if(key === \"phone\") { // 返回经纪人自己的手机号 return 'agent - 18611112222'; } if(key === \"price\") { // 明星不报价，经纪人报价 return 120000; } return target[key]; }, set: function(target, key, val) { if(key === \"customPrice\") { if(val 7.4 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则 7.5 代理模式 VS 适配器模式 适配器模式：提供一个不同的接口（如不同版本的插头） 代理模式：提供一模一样的接口 7.6 代理模式 VS 装饰器模式 装饰器模式：扩展功能，原有功能不变且可直接使用 代理模式：显示原有功能，但是经过限制或者阉割之后的 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter08.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter08.html","title":"设计模式手册 - 8 - 外观模式 ✘","keywords":"","body":"设计模式手册 - 8 - 外观模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:39:23 第八章 外观模式 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口  例子1： 去医院看病，接待员去挂号、门诊、划价、取药，而我们不需要亲手去找 8.1 设计原则元整 不符合单一职责和开放封闭原则，因此谨慎使用，不可滥用 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter09.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter09.html","title":"设计模式手册 - 9 - 观察者模式 ✘","keywords":"","body":"设计模式手册 - 9 - 观察者模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:40:14 第九章 观察者模式 发布 & 订阅 一对多 9.1 实例场景 点咖啡，点好之后坐等被叫 9.2 UML类图 9.3 代码场景 网页绑定事件 Promise jQuery callbacks nodejs 自定义事件 网页绑定事件 btn // 等待按钮被点击，被点击就触发 $(\"#btn1\").click(function() { console.log(1); }) $(\"#btn1\").click(function() { console.log(2); }) $(\"#btn1\").click(function() { console.log(3); }) Promise function loadImg(src) { var promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(\"图片加载失败\"); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"width\", img.width); // width 252 return img; }).then(function(img) { console.log(\"height\", img.height); // height 144 }) jQuery callbacks var callbacks = $.Callbacks(); // 注意大小写 callbacks.add(function(info) { console.log(\"fn1\", info); }) callbacks.add(function(info) { console.log(\"fn2\", info); }) callbacks.add(function(info) { console.log(\"fn3\", info); }) callbacks.fire(\"gogogo!\"); // fn1 gogogo! // fn2 gogogo! // fn3 gogogo! callbacks.fire(\"fire!\"); // fn1 fire! // fn2 fire! // fn3 fire! nodejs 自定义事件 代码1 const EventEmitter = require(\"events\").EventEmitter; const emitter1 = new EventEmitter(); emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 1\"); }) emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 2\"); }) // 触发 some 事件 emitter1.emit(\"some\"); // some event is occured 1 // some event is occured 2 代码2 const EventEmitter = require(\"events\").EventEmitter; const emitter = new EventEmitter(); emitter.on(\"showName\", () => { // 监听 some 事件 console.log(\"event occured\", name); }) emitter.emit(\"showName\", \"jsliang\"); // emit 时候可以传递参数过去 // event occured 代码3 const EventEmitter = require('events').EventEmitter; // 任何构造函数都可以继承 EventEmitter 的方法 on emit class Dog extends EventEmitter { constructor(name) { super(); this.name = name; } } var simon = new Dog(\"simon\"); simon.on(\"bark\", function() { console.log(this.name, \" barked\"); }) setInterval(function() { simon.emit(\"bark\"); }, 1000) // simon barked // simon barked // simon barked // ... 代码4 // Stream 用到了自定义事件 var fs = require(\"fs\"); var readStream = fs.createReadStream(\"./dist/js/index.js\"); // 读取文件的 Stream var length = 0; readStream.on(\"data\", function(chunk) { length += chunk.toString().length(); }) readStream.on(\"end\", function() { console.log(length); }) 9.4 设计原则验证 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter10.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter10.html","title":"设计模式手册 - 10 - 迭代器模式 ✘","keywords":"","body":"设计模式手册 - 10 - 迭代器模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:41:10 第十章 迭代器模式 顺序访问一个集合 使用者无需知道集合的内部结构（封装） 10.1 代码演示 HelloWorld jQuery each jQuery each jQuery each $(function () { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); function each(data) { var $data = $(data); // 生成迭代器 $data.each(function (key, val) { console.log(key, val); }) } each(arr); // 0 1 // 1 2 // 2 3 each(nodeList); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ each($p); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ }) 10.2 UML类图 10.3 使用场景 jQuery each ES6 Iterator: 为何存在？ES6 语法中，有序集合的数据类型已经有很多。Array Map Set String TypedArray arguments NodeList。需要有一个统一的遍历接口来遍历所有数据类型。（注意，object不是有序集合，可以用Map代替）。是什么？以上数据类型，都有 [Symbol.iterator] 属性。属性值是函数，执行函数返回一个迭代器。这个迭代器就有next方法可顺序迭代子元素。可运行 Array.prototype[Symbol.iterator] 来测试。 jQuery each HelloWorld jQuery each jQuery each jQuery each $(function() { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); // 要对这三个变量进行遍历，需要写三个遍历方法 // 第一 arr.forEach(function(item) { console.log(item); // 1 // 2 // 3 }) // 第二 var i, length = nodeList.length; for(i = 0; i jQuery each // jQuery each // jQuery each } // 第三 $p.each(function(key, p) { console.log(key, p); // 0 jQuery each // 1 jQuery each // 2 jQuery each }) }) ES6 Iterator // 旧写法： // function each(data) { // // 生成遍历器 // let iterator = data[Symbol.iterator](); // // console.log(iterator.next()); // 有数据： {value: \"1\", done: false} // // console.log(iterator.next()); // // console.log(iterator.next()); // // console.log(iterator.next()); // 无数据： Cannot read property 'Symbol(Symbol.iterator)' of undefined // let item = {done: false}; // while(!item.done) { // item = iterator.next(); // if(!item.done) { // console.log(item.value); // } // } // } // `Symbol.iterator` 并不是每个人斗志 // 也不是每个人都需要封装一个 each方法 // 因此有了 `for...of` 语法， `for...of`是遍历迭代器的 function each(data) { // 带有遍历器特性的对象： data[Symbol.iterator] 有值 for(let item of data) { console.log(item); } } let arr = [1, 2, 3, 4]; let nodeList = document.getElementsByTagName(\"p\"); let m = new Map(); m.set(\"a\", 100); m.set(\"b\", 200); each(arr); // 1 // 2 // 3 // 4 each(nodeList); // jsliang的设计模式 each(m); // (2) [\"a\", 100] // (2) [\"b\", 200] 10.4 ES6 Iterator 与 Generator Iterator 的价值不限于上述几个类型的遍历 还有 Generator 函数的使用 即只要返回的数据符合 Iterator 接口的要求 即可使用 Iterator 语法，这就是迭代器模式 Generator 应用不是那么广泛了，使用场景比较少 10.5 设计原则验证 迭代器对象和目标对象分离 迭代器将使用者与目标对象隔离开 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter11.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter11.html","title":"设计模式手册 - 11 - 状态模式 ✘","keywords":"","body":"设计模式手册 - 11 - 状态模式 create by jsliang on 2018年9月3日10:30:19Recently revised in 2019-05-20 17:42:49 第十章 状态模式 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用 if...else... 来控制 场景：交通信号灯不同颜色的变化 11.1 UML图 11.2 代码演示 // 状态：红灯、绿灯、蓝灯 class State { constructor(color) { this.color = color; } handle(context) { console.log(`turn to ${this.color} light.`); // 设置状态 context.setState(this); } } // 主体 class Context { constructor() { this.state = null; } // 状态获取 getState() { return this.state; } setState(state) { this.state = state; } } // test let context = new Context(); let green = new State(\"green\"); let yellow = new State(\"yellow\"); let red = new State(\"red\"); // 绿灯亮了 green.handle(context); console.log(context.getState()); // 打印状态 // turn to green light. // State {color: \"green\"} // 黄灯亮了 yellow.handle(context); console.log(context.getState()); // 打印状态 // turn to yellow light. // State {color: \"yellow\"} // 红灯亮了 red.handle(context); console.log(context.getState()); // 打印状态 // turn to red light. // State {color: \"red\"} 11.3 场景 有限状态机 写一个简单的Promise 有限状态机 有限个状态、以及在这些状态之间的变化 如交通信号灯 使用开源 lib： javascipt-state-machine: 详情 javascript-state-machine 来做状态模式： 安装：npm i javascript-state-machine 代码：es6 webpack 环境下 index.html jsliang的设计模式 jsliang的设计模式 --> index.js import StateMachine from 'javascript-state-machine' // 初始化状态机模型 var fsm = new StateMachine({ init: \"收藏\", // 初始状态，待收藏 transitions: [ { name: \"doStore\", from: \"收藏\", to: \"取消收藏\" }, { name: \"deleteStore\", from: \"取消收藏\", to: \"收藏\" } ], methods: { // 监听执行收藏 onDoStore: function() { alert(\"收藏成功\"); // 可以 post 请求 updateText(); }, // 监听取消收藏 onDeleteStore: function() { alert(\"已取消收藏\"); // 可以 post 请求 updateText(); } } }) let $btn = $(\"#btn\"); // 点击事件 $btn.click(function() { if(fsm.is(\"收藏\")) { fsm.doStore(); } else { fsm.deleteStore(); } }) // 更新文案 function updateText() { $btn.text(fsm.state); } // 初始化文案 updateText(); 写一个简单的 Promise 回顾 Promise 的语法 分析：Promise 就是一个有限状态机 写代码 测试验证 function loadImg(src) { const promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"success 1\"); }, function() { console.log(\"failed 1\"); }) // success 1 result.then(function(img) { console.log(\"success 2\"); }, function() { console.log(\"failed 2\"); }) // success 2 /** * 如果地址错误，则： * logo_new1.png:1 GET http://www.imooc.com/static/img/index/logo_new1.png 404 (Not Found) * failed 1 * failed 2 */ Promise 就是有限状态机 Promise 三种状态： pending fullfilled rejected pending -> fullfilled 或者 pending -> rejected 不能逆向变化 import StateMachine from 'javascript-state-machine'; // 状态机模型 var fsm = new StateMachine({ init: \"pending\", transitions: [ { name: \"resolve\", from: \"pending\", to: \"fullfilled\" }, { name: \"reject\", from: \"pending\", to: \"rejected\" } ], methods: { // 监听 resolve 成功 onResolve: function(state, data) { // 参数：state - 当前状态示例；data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn => fn()); }, // 失败 onReject: function(state, data) { // 参数：state - 当前状态示例；data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn => fn()); } } }) // 定义 Promise class MyPromise { constructor(fn) { this.successList = []; this.failList = []; fn(() => { // resolve 函数 fms.resolve(this); }, () => { // reject 函数 fsm.reject(this); }) } then(successFn, failFn) { this.successList.push(successFn); this.failList.push(failFn); } } // 测试代码 function loadImg(src) { const promise = new Promise(function(resolve, reject) { let img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } let src = \"http://www.imooc.com/static/img/index/logo_new.png\"; let result = loadImg(src); result.then(function() { console.log(\"ok1\"); }, function() { console.log(\"fail1\"); }) // ok1 result.then(function() { console.log(\"ok2\"); }, function() { console.log(\"fail2\"); }) // ok2 11.4 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter12.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter12.html","title":"设计模式手册 - 12 - 其他模式 ✘","keywords":"","body":"设计模式手册 - 12 - 其他模式 create by jsliang on 2018年9月3日11:53:05Recently revised in 2019-05-20 17:42:42 第十二章 其他模式  这里讲解前11章之外，比较少用的模式。 原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式 12.1 原型模式 clone 自己，生成一个新对象 Java 默认有 clone 接口，不用自己实现 对比 JS 中的原型 prototype： prototype 可以理解为 ES6 class 的一种底层原理 而 class 是实现面向对象的基础，并不是服务于某个模式 若干年后如果 ES6 全面普及，大家可能会忽略掉 prototype 但是 Object.create 却会长久存在 // `Object.create` 用到了原型模式的思想（虽然不是 java 中的 clone ） // 基于一个原型创建一个对象 var prototype = { getName: function() { return this.first + \" \" + this.last; }, say: function() { console.log(\"hello\"); } } // 基于原型创建 x let x = Object.create(prototype); x.first = \"A\"; x.last = \"B\"; alert(x.getName()); // A B x.say(); // hello 12.2 桥接模式 用户把抽象化与实现化解耦 使得二者可以独立变化 原实例场景 class ColorShape { yellowCircle() { console.log(\"yellow circle\"); } redCircle() { console.log(\"red circle\"); } yellowTriangle() { console.log(\"yellow triangle\"); } redTriangle() { console.log(\"red triangle\"); } } // 测试 let cs = new ColorShape(); cs.yellowCircle(); // yellow circle cs.redCircle(); // red circle cs.yellowTriangle(); // yellow triangle cs.redTriangle(); // red triangle 使用桥接模式 class Color { constructor(name) { this.name = name; } } class Shape { constructor(name, color) { this.name = name; this.color = color; } draw() { console.log(`${this.color.name} ${this.name}`); } } // 测试代码 let red = new Color(\"red\"); let yellow = new Color(\"yellow\"); let circle = new Shape(\"circle\", red); circle.draw(); // red circle let triangle = new Shape(\"triangle\", yellow); triangle.draw(); // yellow triangle 设计原则验证 抽象和实现分离，解耦 符合开放封闭原则 12.3 组合模式 生成树形结构，表示“整体-部分”关系 让整体和部分都具有一致的操作模式 123 456 { tag: \"div\", attr: { id: \"div1\", className: \"container\" }, children: [ { tag: \"p\", attr: {}, children: [\"123\"] }, { tag: \"p\", attr: {}, children: [\"456\"] } ] } 整体和单个节点的操作是一致的 整体和单个节点的数据结构也保持一致 设计原则验证 将整体和单个节点的操作抽象出来 符合开放封闭原则 12.4 享元模式 共享内存（主要考虑内存，而非效率） 相同的数据，共享使用 `标签，对内存开销太大 --> a1 a2 a3 a4 var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(e.nodeName === \"A\") { alert(target.innerHTML); } }) 设计原则验证 将相同的部分抽象出来 符合开放封闭原则 12.5 策略模式 不同策略分开处理 避免出现大量 if...else... 或者 switch...case... 原代码实现 class User { constructor(type) { this.type = type; } buy() { if(this.type === \"ordinary\") { console.log(\"普通用户购买\"); } else if(this.type === \"member\") { console.log(\"会员用户购买\"); } else if(this.type === \"vip\") { console.log(\"vip 用户购买\"); } } } 策略模式代码实现针对不用的用户，设计不用的类，从而解耦用户等级 class OrdinaryUser { buy() { console.log(\"普通用户购买\"); } } class MemberList { buy() { console.log(\"会员用户购买\"); } } class VipUser { buy() { console.log(\"vip 用户购买\"); } } var u1 = new OrdinaryUser(); u1.buy(); var u2 = new MemberList(); u2.buy(); var u3 = new VipUser(); u3.buy(); // 测试代码 var u1 = new User(\"ordinary\"); u1.buy(); // 普通用户购买 var u2 = new User(\"member\"); u2.buy(); // 会员用户购买 var u3 = new User(\"vip\"); u3.buy(); // vip 用户购买 设计原则验证 不同策略，分开处理，而不是混合在一起 符合开放封闭原则 12.6 模板方法模式 class Action { handle() { handle1(); handle2(); handle3(); } handle1() { console.log(\"1\"); } handle2() { console.log(\"2\"); } handle3() { console.log(\"3\"); } } let action = new Action(); action.handle(); 12.7 职责连模式 一步操作可能分为多个职责来完成 把这些角色都分开，然后用一个链串起来 将发起者和各个处理者进行隔离 // 请假审批，需要组长审批、经理审批、最后总监审批 class Action { constructor(name) { this.name = name; this.nextAction = null; } setNextAction(action) { this.nextAction = action; } handle() { console.log(`${this.name} 审批`); if(this.nextAction != null) { this.nextAction.handle(); } } } let a1 = new Action(\"组长\"); let a2 = new Action(\"经理\"); let a3 = new Action(\"总监\"); a1.setNextAction(a2); a2.setNextAction(a3); a1.handle(); // 组长 审批 // 经理 审批 // 总监 审批 使用场景 职责链模式和业务结合较多，JS 中能联想到链式操作 jQuery 的链式操作， Promise.then 的链式操作 设计原则验证 发起者于各个处理者进行隔离 符合开放封闭原则 12.8 命令模式模式 执行命令时，发布者和执行者分开 中间加入命令对象，作为中转站 将军发布命令，先告诉副官，由副官进行传达，而不是将军一个一个告诉军队 董事长实施战略，先告诉经理，至于各部门如何协调，让经理进行排期。 // 接受者 class Receiver { exec() { console.log(\"执行\"); } } // 命令者 class Command { constructor(receiver) { this.receiver = receiver; } cmd() { console.log(\"触发命令\"); this.receiver.exec(); } } // 触发者 class Invoker { constructor(command) { this.command = command; } invoke() { console.log(\"开始\"); this.command.cmd(); } } // 士兵 let soldier = new Receiver(); // 小号手 let trumpeter = new Command(soldier); // 将军 let general = new Invoker(trumpeter); general.invoke(); // 开始 // 触发命令 // 执行 JS 中的应用 网页富文本编辑器操作，浏览器封装了一个命令对象 document.execCommand(\"bold\") document.execCommand(\"undo\") 设计原则验证 命令对象于执行对象分开，解耦 符合开放封闭原则 12.9 备忘录模式 随时记录一个对象的状态变化 随时可以恢复之前的某个状态（如撤销功能） // 状态备忘 class Memento { constructor(content) { this.content = content; } getContent() { return this.content; } } // 备忘列表 class CareTaker { constructor() { this.list = []; } add(memento) { this.list.push(memento); } get(index) { return this.list[index]; } } // 编辑器 class Editor { constructor() { this.content = null; } setContent(content) { this.content = content; } getContent() { return this.content; } saveContentToMemento() { return new Memento(this.content); } getContentFromMemento(memento) { this.content = memento.getContent(); } } // 测试代码 let editor = new Editor(); let careTaker = new CareTaker(); editor.setContent(\"111\"); editor.setContent(\"222\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"333\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"444\"); console.log(editor.getContent()); // 444 editor.getContentFromMemento(careTaker.get(1)); // 撤销 console.log(editor.getContent()); // 333 editor.getContentFromMemento(careTaker.get(0)); // 撤销 console.log(editor.getContent()); // 222 /** * 这里是预知了要撤销的步骤 * 假如，不知道要存储了多少条备忘录 * 而我们要一步步回撤，则需要怎么做？ * 个人想法就是还需要一个计步器 * 就是你存了多少备忘录，则记起来 * 当你需要回撤的时候，直接读取最近的备忘条数 * 即可回撤到最近一步操作 */ 设计原则验证 状态对象与使用者分开，解耦 符合开放封闭原则 12.10 中介者模式 中介者原理 class Mediator { constructor(a, b) { this.a = a; this.b = b; } setA() { let number = this.b.number; this.a.setNumber(number * 100); } setB() { let number = this.a.number; this.b.setNumber(number / 100); } } class A { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setB(); } } } class B { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setA(); } } } // 测试 let a = new A(); let b = new B(); let m = new Mediator(a, b); a.setNumber(100, m); console.log(a.number, b.number); // 100 1 b.setNumber(100, m); console.log(a.number, b.number); // 10000 100 设计原则验证 将各关联对象通过中介者隔离 符合开放封闭原则 12.11 访问者模式 将数据操作和数据结构进行分离 使用场景不多 12.12 解释器模式 描述语言语法如何定义，如何解释和编译 用于专业场景 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "},"JavaScript-library/design-pattern/design-pattern-chapter13.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter13.html","title":"设计模式手册 - 13 - 综合应用 ✘","keywords":"","body":"设计模式手册 - 13 - 综合应用 create by jsliang on 2018年9月4日09:37:55Recently revised in 2019-05-20 17:44:37 第十三章 综合应用-购物车  最后，我们使用 jQuery 做一个模拟购物车的示例。 功能如下： 显示购物列表 加入购物车 从购物车删除 涉及的设计模式： 工厂模式 单例模式 装饰器模式 观察者模式 状态模式 模板方法模式 代理模式 13.1 UML类图 13.2 编程环境搭建  如果小伙伴有跟着 部署开发环境 搭建了属于自己的设计模式环境，那么，就让我们优化一下直接跑起我们的综合应用就OK了~如果小伙伴没有去做，那么先跟着 部署开发环境 先跑一遍，再回来做我们的综合应用吧！前往：第一章 部署开发环境  OK，Here we go! 我们目前的目录 目录文件  在这里，我们先过一遍我们的文件，没有配置设计模式环境的小伙伴可以照上面的图新建过文件目录，配置好的小伙伴看看代码和 jsliang 的代码是否一致：  dist - 打包后的文件存放地方  dist/js - 该文件夹为打包后的 js 文件存储位置，这里的 index.js 系自动生成，无需新增该文件  dist/index.html - 打包后的 index.html ，一般是依据原有的 index.html ，打包时 webpack 往里面添加 \\ ，这里我们需要添加下列代码进去。 jsliang的设计模式 Hello 综合应用！ --> -->  node_modules - npm 安装包，在拷贝了其他文件的代码后，我们 npm i 会自动生成  src/index.js - 被打包的 js 文件，暂时不需要添加代码  .babelrc - es6、es7 代码转为 es5 代码所必需的文件 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] }  package.json - 项目的依据，所依赖的插件都在这里提示 { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" }, \"dependencies\": { \"core-decorators\": \"^0.20.0\", \"javascript-state-machine\": \"^3.1.0\", \"jquery\": \"^3.3.1\" } }  webpack.dev.config.js - webpack 开发模式下会使用到的 loader 以及插件等配置 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 // host: \"192.168.1.87\" // WiFi IPV4地址，打开可共享到手机 } }  webpack.prod.config.js - 生产环境，打包文件到 dist 目录，然后发布到服务器上即可生效访问 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 复制粘贴完这些代码之后，我们就可以跑起项目来了！ 安装 npm 包：npm i 进入开发模式：npm run dev 生产模式打包：npm run build  很好，上面就是我们原有的目录，让我们往里面新增代码，配置综合应用的环境吧： 搭建完后的目录  如图，我们需要往 src 目录下新增 api 文件夹及其 list.json 以及 src 目录下的 App.js。  然后，我们需要往 webpack.dev.config.js 中的 devServer 添加解决跨域的代码，因为我们将采用其他端口作为我们的 API 地址： proxy: { \"/api/*\": { // url 中匹配到 \"/api\" 之前的东西，将其全部替换成下面 target 中的东西，从而解决跨域问题 target: \"http://localhost:8880\" } }  此刻我们的 index.js 、App.js 以及 list.json 文件内容如下： index.js - 启动文件，通过 index.js 访问 App.js 这个主入口 import App from './demo/App.js' let app = new App('app'); app.init(); App.js - 项目主入口 export default class App { constructor(id) { } init() { console.log(\"初始化成功！\"); } } list.json - api接口文件，提供书籍清单 [ { \"id\": 1, \"name\": \"《JS 基础面试题》\", \"price\": 149, \"discount\": 1 }, { \"id\": 2, \"name\": \"《JS 高级面试题》\", \"price\": 366, \"discount\": 1 }, { \"id\": 3, \"name\": \"《React 模拟大众点评 webapp》\", \"price\": 248, \"discount\": 0 }, { \"id\": 4, \"name\": \"《zepto 设计与源码解读》\", \"price\": 0, \"discount\": 0 } ]  到这里，我们一切准备就绪，只需要执行两步即可： cd 到 demo 目录中，打开接口服务： cd src/demo http-server -p 8880 这时候我们打开下面地址，会发现该 api 接口成功开启： 打开开发模式： npm run start 这时候浏览器会自动打开 localhost:9000 ，如果没有打开，请在浏览器输入 http://localhost:9000 即可访问到：  好的，到此为止，我们已经完美部署了我们综合应用的开发环境，让我们继续前进吧！ 13.3 代码剖析 步骤1 inde.js import App from './demo/App.js' let app = new App('app'); app.init(); App.js import $ from 'jquery' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { console.log(\"初始化购物车\"); } // 初始化列表 initList() { console.log(\"初始化列表\"); } init() { this.initShoppingCart(); this.initList(); } } 步骤2 步骤3 ShoppingCart.js export default class ShoppingCart { constructor(app) { } init() { } } List.js export default class ShoppingCart { constructor(app) { } init() { } } App.js import $ from 'jquery' import ShoppingCart from './ShoppingCart/ShoppingCart.js' import List from './List/List.js' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { let shoppingCart = new ShoppingCart(this); shoppingCart.init(); } // 初始化列表 initList() { let list = new List(this); list.init(); } init() { this.initShoppingCart(); this.initList(); } } 步骤4 List.js import $ from 'jquery' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { } // 生成列表 initItemList(data) { } // 渲染 render() { } init() { } } 步骤5 config.js export const GET_LIST = '/api/list.json' 步骤6 List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { data.map(itemData => { // 创建一个 Item 然后 init }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤7 GetCart.js class Cart { constructor() { this.list = []; } add(data) { this.list.push(data); } del(id) { this.list = this.list.filter(item => { if(item.id === id) { return false; } return true; }) } getList() { return this.list.map(item => { return item.name; }).join('\\n'); } } // 返回单例 let getCart = (function() { let cart; return function() { if(!cart) { cart = new Cart(); } return cart; } })() export default getCart; 步骤8 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.name}`)); } initBtn() { let $el = this.$el; let $btn = $('test'); $btn.click(() => { // 添加到购物车 // 从购物车移除 }) $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤9 CreateItem.js import Item from './Item.js' // 补充：优惠商品的处理逻辑 // 工厂函数 export default function(list, itemData) { return new Item(list, itemData); } List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' import createItem from './CreateItem.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { // data.map(itemData => { // // 创建一个 Item 然后 init // let item = createItem(this, itemData); // item.init(); // return item; // }) data.forEach(itemData => { // 创建一个 Item 然后 init let item = createItem(this, itemData); item.init(); }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤10 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤11 步骤12 ShoppingCart.js import $ from 'jquery'; import getCart from './GetCart.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $('').css({ 'padding-bottom': '10px;', 'border-bottom': '1px solid #ccc' }) this.cart = getCart(); } initBtn() { let $btn = $('购物车'); $btn.click(() => { this.showCart(); }) this.$el.append($btn); } showCart() { alert(this.cart.getList()); } render() { this.app.$el.append(this.$el); } init() { this.initBtn(); this.render(); } } 步骤13 CreateItem.js import Item from './Item.js' function createDiscount(itemData) { // 用代理做折扣显示 return new Proxy(itemData, { get: function(target, key, receiver) { if(key === 'name') { return `${target[key]} 【折扣】`; } if(key === 'price') { return target[key] * 0.8; } return target[key]; } }) } // 工厂函数 export default function(list, itemData) { if(itemData.discount) { itemData = createDiscount(itemData); } return new Item(list, itemData); } 步骤14 log.js export function log(type) { return function(target, name, descriptor) { let oldValue = descriptor.value; descriptor.value = function() { // 在此统一打印日志 console.log(`日志上报 ${type}`); // 执行原有的方法 return oldValue.apply(this, arguments); } return descriptor; } } Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; import { log } from '../util/log.js' export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 @log('add') // 装饰器模式 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 @log('del') deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 13.4 总结  项目中使用到的模式： 工厂模式：$('×××')，创建商品 单例模式：购物车 装饰器模式：打点统计 观察者模式：网页事件，Promise 状态模式：添加到购物车 & 从购物车删除 模板方法模式：渲染有统一的方法，内部包含了各模块渲染 代理模式：打折商品信息处理 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 13:14:15 "}}